<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on beanlam</title>
    <link>/categories/java/</link>
    <description>Recent content in java on beanlam</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 21 Mar 2019 17:36:44 +0800</lastBuildDate>
    
	<atom:link href="/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 各版本的特性（更新到 Java 12）</title>
      <link>/2019/java-features/</link>
      <pubDate>Thu, 21 Mar 2019 17:36:44 +0800</pubDate>
      
      <guid>/2019/java-features/</guid>
      <description>JDK 1.1 (1997 年 2 月 19 号)  引入 JDBC (Java Database Connectivity)； 引入内部类 (Inner Classes)； 引入 Java Beans； 引入 RMI (Remote Method Invocation)； 添加只支持内省(Introspection)，但不允许在运行时改动的Java反射机制； 对 AWT(java.awt) 事件模型进行大范围的改进； 支持 Internationalization 和 Unicode；  J2SE 1.2 (1998 年 12 月 4 号)  引入 Java 插件； 引入集合(Collection)框架； 引入 JIT(Just In Time)编译器； 引入 JFC(Java Foundation Classes)，包括 Swing 1.0、拖放和 Java 2D 类库； 引入对打包的 Java 文件进行数字签名； 引入控制授权访问系统资源的策略工具； 对字符串常量做内存映射； 在 Applet 中添加声音支持； 在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型； 新增关键字 strictfp(strict float point)； 添加可与 CORBA 协同交互的 Java IDL；  J2SE 1.</description>
    </item>
    
    <item>
      <title>图与其Java实现</title>
      <link>/2015/java-graph/</link>
      <pubDate>Fri, 17 Apr 2015 18:07:51 +0800</pubDate>
      
      <guid>/2015/java-graph/</guid>
      <description>图的基本概念 图是什么，图是一种数据结构，一种非线性结构，所谓的非线性结构，浅显地理解的话，就是图的存储不是像链表这样的线性存储结构，而是由两个集合所组成的一种数据结构。
一个图中有两类东西，一种是结点，一种结点之间的连线。要用一种数据结构来表示的话，首先我们需要一个集合来存储所有的点，我们用V这个集合来表示（vertex），还需要另一个集合来存储所有的边，我们用E来表示(Edge)，那么一个图就可以表示为：
 G = (V，E）
 有的图的边是有方向的，有的是没有方向的。
（A,B）表示A结点与B结点之间无方向的边，&amp;lt;A,B&amp;gt;则表示方向为从A到B的一条边，当然，如果是&amp;lt;B,A&amp;gt;，则方向相反。因此从边的方向我们就可以把图分为有向图和无向图两种。
其它概念 一个图中的元素有很多，例如：
 完全图，邻接节点，结点的度，路径，权，路径长度，子图，连通图和强连通图，生成树，简单路径和回路&amp;hellip;
 本文只说说容易混淆的概念。
完全图，连通图，与强连通图 完全图可分为有向完全图和无向完全图两种，如果一个图的任意两个结点之间有且只有一条边，则称此图为无向完全图，若任意两个结点之间有且只有方向相反的两条边，则称为有向完全图。
那么连通图与完全图有什么区别呢？连通图是指在无向图中，若图中任意一对结点之间都有路径可达，则称这个无向图是连通图，而强连通图则是对应于有向图来说的，其特点与连通图是一样的。只不过是有向的，所以加了&amp;quot;强&amp;rdquo;。
连通图与完全图的区别就是，完全图要求任意两点之间有边，而连通图则是要求有路径。边和路径是有区别的。
邻接结点 一个结点的邻接节点，对于无向图来说，就是与这个结点相连的结点，至少有一个。
对于有向图来说，由于边是有方向的，所以一个结点的邻接节点是指以这个结点为开头，所指向的那些结点。
结点的度 度是针对结点来说的， 又分为出度和入度，看到“出度入度”，我们不难想到这是与边和边的方向有关的。 对于无向图来说，没有出度入度之分，一个结点的度就是经过这个结点的边的数目(或者是与这个结点相关联的边的数目)，对于有向图来说，出度就是指以这个结点为起始的边的条数（箭头向外），入度则是以这个点为终点的边的条数（箭头向内）。
出 = 箭头向外，入 = 箭头向内
权 权是指一条边所附带的数据信息，比如说一个结点到另一个结点的距离，或者花费的时间等等都可以用权来表示。带权的图也称为网格或网。
子图 跟一个集合有子集一样，图也有子图。可以类比理解。
存储结构 要存储一个图，我们知道图既有结点，又有边，对于有权图来说，每条边上还带有权值。常用的图的存储结构主要有以下二种：
 邻接矩阵 邻接表  邻接矩阵 我们知道，要表示结点，我们可以用一个一维数组来表示，然而对于结点和结点之间的关系，则无法简单地用一维数组来表示了，我们可以用二维数组来表示，也就是一个矩阵形式的表示方法。
我们假设A是这个二维数组，那么A中的一个元素aij不仅体现出了结点vi和结点vj的关系，而且aij的值正可以表示权值的大小。
以下是一个无向图的邻接矩阵表示示例：
从上图我们可以看到，无向图的邻接矩阵是对称矩阵，也一定是对称矩阵。且其左上角到右下角的对角线上值为零（对角线上表示的是相同的结点）
有向图的邻接矩阵是怎样的呢？
邻接表 我们知道，图的邻接矩阵存储方法用的是一个n*n的矩阵，当这个矩阵是稠密的矩阵（比如说当图是完全图的时候），那么当然选择用邻接矩阵存储方法。 可是如果这个矩阵是一个稀疏的矩阵呢，这个时候邻接表存储结构就是一种更节省空间的存储结构了。 对于上文中的无向图，我们可以用邻接表来表示，如下：
每一个结点后面所接的结点都是它的邻接结点。
邻接矩阵与邻接表的比较 当图中结点数目较小且边较多时，采用邻接矩阵效率更高。 当节点数目远大且边的数目远小于相同结点的完全图的边数时，采用邻接表存储结构更有效率。
邻接矩阵的Java实现 邻接矩阵模型类 邻接矩阵模型类的类名为AMWGraph.java，能够通过该类构造一个邻接矩阵表示的图，且提供插入结点，插入边，取得某一结点的第一个邻接结点和下一个邻接结点。
import java.util.ArrayList; import java.util.LinkedList; /** * @description 邻接矩阵模型类 * @author beanlam * @time 2015.</description>
    </item>
    
  </channel>
</rss>