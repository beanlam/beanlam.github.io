<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>java on beanlam</title>
    <link>/categories/java/</link>
    <description>Recent content in java on beanlam</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 21 Mar 2019 17:36:44 +0800</lastBuildDate>
    
	<atom:link href="/categories/java/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 各版本的特性（更新到 Java 12）</title>
      <link>/2019/java-features/</link>
      <pubDate>Thu, 21 Mar 2019 17:36:44 +0800</pubDate>
      
      <guid>/2019/java-features/</guid>
      <description>JDK 1.1 (1997 年 2 月 19 号)  引入 JDBC (Java Database Connectivity)； 引入内部类 (Inner Classes)； 引入 Java Beans； 引入 RMI (Remote Method Invocation)； 添加只支持内省(Introspection)，但不允许在运行时改动的Java反射机制； 对 AWT(java.awt) 事件模型进行大范围的改进； 支持 Internationalization 和 Unicode；  J2SE 1.2 (1998 年 12 月 4 号)  引入 Java 插件； 引入集合(Collection)框架； 引入 JIT(Just In Time)编译器； 引入 JFC(Java Foundation Classes)，包括 Swing 1.0、拖放和 Java 2D 类库； 引入对打包的 Java 文件进行数字签名； 引入控制授权访问系统资源的策略工具； 对字符串常量做内存映射； 在 Applet 中添加声音支持； 在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型； 新增关键字 strictfp(strict float point)； 添加可与 CORBA 协同交互的 Java IDL；  J2SE 1.</description>
    </item>
    
    <item>
      <title>Java 中的 Monitor 机制</title>
      <link>/2018/java-monitor/</link>
      <pubDate>Wed, 12 Sep 2018 18:24:59 +0800</pubDate>
      
      <guid>/2018/java-monitor/</guid>
      <description>monitor的概念 管程，英文是 Monitor，也常被翻译为“监视器”，monitor 不管是翻译为“管程”还是“监视器”，都是比较晦涩的，通过翻译后的中文，并无法对 monitor 达到一个直观的描述。 在《操作系统同步原语》 这篇文章中，介绍了操作系统在面对 进程/线程 间同步的时候，所支持的一些同步原语，其中 semaphore 信号量 和 mutex 互斥量是最重要的同步原语。 在使用基本的 mutex 进行并发控制时，需要程序员非常小心地控制 mutex 的 down 和 up 操作，否则很容易引起死锁等问题。为了更容易地编写出正确的并发程序，所以在 mutex 和 semaphore 的基础上，提出了更高层次的同步原语 monitor，不过需要注意的是，操作系统本身并不支持 monitor 机制，实际上，monitor 是属于编程语言的范畴，当你想要使用 monitor 时，先了解一下语言本身是否支持 monitor 原语，例如 C 语言它就不支持 monitor，Java 语言支持 monitor。 一般的 monitor 实现模式是编程语言在语法上提供语法糖，而如何实现 monitor 机制，则属于编译器的工作，Java 就是这么干的。
monitor 的重要特点是，同一个时刻，只有一个 进程/线程 能进入 monitor 中定义的临界区，这使得 monitor 能够达到互斥的效果。但仅仅有互斥的作用是不够的，无法进入 monitor 临界区的 进程/线程，它们应该被阻塞，并且在必要的时候会被唤醒。显然，monitor 作为一个同步工具，也应该提供这样的管理 进程/线程 状态的机制。想想我们为什么觉得 semaphore 和 mutex 在编程上容易出错，因为我们需要去亲自操作变量以及对 进程/线程 进行阻塞和唤醒。monitor 这个机制之所以被称为“更高级的原语”，那么它就不可避免地需要对外屏蔽掉这些机制，并且在内部实现这些机制，使得使用 monitor 的人看到的是一个简洁易用的接口。</description>
    </item>
    
    <item>
      <title>Java 线程的实现方式</title>
      <link>/2018/java-thread-impl/</link>
      <pubDate>Thu, 06 Sep 2018 18:28:28 +0800</pubDate>
      
      <guid>/2018/java-thread-impl/</guid>
      <description>进程与线程 在传统的操作系统中，最核心的概念是“进程”，进程是对正在运行的程序的一个抽象。 进程的存在让“并行”成为了可能，在一个操作系统中，允许运行着多个进程，这些进程“看起来”是同时在运行的。 如果我们的计算机同时运行着 web 浏览器、电子邮件客户端、即时通讯软件例如QQ微信等多个进程，我们感觉这些进程都是同时在运行的，假设这台计算机搭配的是多个 CPU 或者 多核 CPU，那么这种多个进程并行的现象可能一点也不奇怪，完全可以为每个进程单独分配一个 CPU，这样就实现了多进程并行。 然而事实上，在计算机只有一个 CPU 的情况下，它也能给人类一种感觉：多个进程同时在运行。但人类的感觉往往是比较模糊的，不精确的。事实是由于 CPU 的计算速度非常地快，它能快速地在各个进程之间切换，在某一瞬间，CPU 只能运行一个进程，但一秒钟之内，它就能通过快速切换，让人产生多个进程同时在运行的错觉。 在操作系统中，为什么在进程的基础上，又衍生出了线程的概念呢？
 由于对于一些进程而言，它内部会发生多种活动，有些活动可能会在某个时间里阻塞，有些活动不会，如果通过线程将这些活动分离开使它们能够并行地运行，则设计程序的时候会更加简单。 线程比进程的创建更加轻量级，性能消耗更少 如果一个进程既需要 CPU 计算，也需要I/O处理，拥有多线程允许这些活动重叠进行，加快整个进程的执行速度。  每一个进程在操作系统中都拥有独立的一块内存地址空间，该进程创建的所有线程共享这块内存，支持多线程的操作系统，会让线程作为 CPU 调度的最小单位。CPU 的时间片在不同的线程之间进行分配。
线程的可能实现方式 基本上主流的操作系统都支持线程，也提供了线程的实现。而 Java 语言为了应对不同硬件和操作系统的差异，提供了对线程操作的统一抽象，在 Java 中我们使用 Thread 类来代表一个线程。 Thread 的具体实现可能会有不同的实现方式：
使用内核线程实现 内核线程是操作系统内核支持的线程，在内核中有一个线程表用来记录系统中的所有线程，创建或者销毁一个线程时，都需要涉及到系统调用，然后再内核中对线程表进行更新操作。对内核线程的阻塞以及其它操作，都涉及到系统调用，系统调用的代价都比较大，涉及到在用户态和内核态之间的来回切换。此外，内核内部有线程调度器，用于决定应该将 CPU 时间片分配个哪个线程。 程序一般不会直接操作内核线程，而是使用内核线程的一种高级接口，轻量级进程。轻量级进程与内核线程之间的关系是 1：1，每一个轻量级进程内部都有一个内核线程支持。
上图中， LWP 指 Light Weight Process，即轻量级进程；KLT 指 Kernel Level Thread，即内核线程。
使用用户线程实现 用户线程是程序或者编程语言自己实现的线程库，系统内核无法感知到这些线程的存在。用户线程的建立、同步、销毁和调度，都在用户态中完成，无须内核的帮助，不需要进行系统调用，这样的好处是对于线程的操作是非常高效的。在这种情况下，进程和用户线程的比例是 1 ：N。
用户态线程面对如何阻塞线程时，会面临困难，阻塞一个用户态线程会出现把整个进程都阻塞的情况，多线程也就失去了意义。因为缺少内核的支持，所以很多需要利用内核才能完成的工作，例如阻塞与唤醒线程、多 CPU 环境下线程的映射等，都需要用户程序去实现，实现起来会异常困难。
使用用户线程和内核线程混合实现 在这种混合实现下，既存在用户线程，也存在内核线程。用户态线程的创建、切换这些操作依然很高效，并且用户态实现的线程，比较容易加大线程的规模。需要操作系统内核支持的功能，则通过内核线程来做到，例如映射到不同的处理器上、处理线程的阻塞与唤醒以及内核线程的调度等。这种实现依然会使用到轻量级进程 LWP，它是用户线程和内核线程之间的桥梁。
Java 线程的实现 在 JDK1.2 之前， Java 的线程是使用用户线程实现的，在 JDK1.</description>
    </item>
    
    <item>
      <title>Java Trouble Shooting</title>
      <link>/2017/java-trouble-shooting/</link>
      <pubDate>Tue, 06 Jun 2017 18:33:55 +0800</pubDate>
      
      <guid>/2017/java-trouble-shooting/</guid>
      <description>什么是线程栈(thread dump) 线程栈是某个时间点，JVM所有线程的活动状态的一个汇总；通过线程栈，可以查看某个时间点，各个线程正在做什么，通常使用线程栈来定位软件运行时的各种问题，例如 CPU 使用率特别高，或者是响应很慢，性能大幅度下滑。
线程栈包含了多个线程的活动信息，一个线程的活动信息通常看起来如下所示：
&amp;#34;main&amp;#34; prio=10 tid=0x00007faac0008800 nid=0x9f0 waiting on condition [0x00007faac6068000] java.lang.Thread.State: TIMED_WAITING (sleeping) at java.lang.Thread.sleep(Native Method) at ThreadDump.main(ThreadDump.java:4) 这条线程的线程栈信息包含了以下这些信息：
 线程的名字：其中 main 就是线程的名字，需要注意的是，当使用 Thread 类来创建一条线程，并且没有指定线程的名字时，这条线程的命名规则为 Thread-i，i 代表数字。如果使用 ThreadFactory 来创建线程，则线程的命名规则为 pool-i-thread-j，i 和 j 分别代表数字。 线程的优先级：prio=10 代表线程的优先级为 10 线程 id：tid=0x00007faac0008800 代表线程 id 为 0x00007faac0008800，而** nid=0x9f0** 代表该线程对应的操作系统级别的线程 id。所谓的 nid，换种说法就是 native id。在操作系统中，分为内核级线程和用户级线程，JVM 的线程是用户态线程，内核不知情，但每一条 JVM 的线程都会映射到操作系统一条具体的线程 线程的状态：java.lang.Thread.State: TIMED_WAITING (sleeping) 以及 waiting on condition 代表线程当前的状态 线程占用的内存地址：[0x00007faac6068000] 代表当前线程占用的内存地址 线程的调用栈：at java.lang.Thread.sleep(Native Method) 以及它之后的相类似的信息，代表线程的调用栈  回顾线程状态  NEW：线程初创建，未运行 RUNNABLE：线程正在运行，但不一定消耗 CPU BLOCKED：线程正在等待另外一个线程释放锁 WAITING：线程执行了 wait, join, park 方法 TIMED_WAITING：线程调用了sleep, wait, join, park 方法，与 WAITING 状态不同的是，这些方法带有表示时间的参数。  例如以下代码：</description>
    </item>
    
    <item>
      <title>Java 实现生命周期管理机制</title>
      <link>/2016/java-lifecycle/</link>
      <pubDate>Wed, 13 Jan 2016 18:22:03 +0800</pubDate>
      
      <guid>/2016/java-lifecycle/</guid>
      <description>前言 最近一直在研究某个国产开源的MySQL数据库中间件，拉下其最新版的代码到eclipse后，启动起来，然后做各种测试和代码追踪；用完想要关闭它时，拉出它的STOP类想要运行时，发现这个类里赫然只写以下几行代码，于是我感觉瞬间受到了很多伤害。
public static void main(String[] args) { System.out.println(new Date() + &amp;#34;,server shutdown!&amp;#34;); } 这个中间件启动和运行的时候，开启了监听，启动着许多线程在跑着，并且有许多socket连接。但是并没有找到一个优雅的方式将其关闭。于是无奈之下，我只能去点eclipse的心碎小红点，强行停掉VM。
如果是一个架构良好，模块化清晰的软件，特别是Server类的软件，拥有一套生命周期管理机制是非常重要的。不仅可以管理各个模块的生命周期，也可以在启停整个软件的时候更优雅，不会漏掉任何资源。
生命周期机制简易实现 生命周期状态 一个模块的生命周期状态一般有以下几个：
 新生 -&amp;gt; 初始化中 -&amp;gt; 初始化完成 -&amp;gt; 启动中 -&amp;gt; 启动完成 -&amp;gt; 正在暂停 -&amp;gt; 已经暂停 -&amp;gt; 正在恢复 -&amp;gt; 已经恢复 -&amp;gt; 正在销毁 -&amp;gt; 已经销毁
 其中，任何一个状态之间的转化如果失败，那么就会进入另外一种状态：失败。
为此，可以用一个枚举类来枚举出这几个状态，如下所示：
public enum LifecycleState { NEW, //新生  INITIALIZING, INITIALIZED, //初始化  STARTING, STARTED, //启动  SUSPENDING, SUSPENDED, //暂停  RESUMING, RESUMED,//恢复  DESTROYING, DESTROYED,//销毁  FAILED;//失败  } 接口 生命周期中的各种行为规范，也需要一个接口来定义，如下所示:</description>
    </item>
    
    <item>
      <title>图与其Java实现</title>
      <link>/2015/java-graph/</link>
      <pubDate>Fri, 17 Apr 2015 18:07:51 +0800</pubDate>
      
      <guid>/2015/java-graph/</guid>
      <description>图的基本概念 图是什么，图是一种数据结构，一种非线性结构，所谓的非线性结构，浅显地理解的话，就是图的存储不是像链表这样的线性存储结构，而是由两个集合所组成的一种数据结构。
一个图中有两类东西，一种是结点，一种结点之间的连线。要用一种数据结构来表示的话，首先我们需要一个集合来存储所有的点，我们用V这个集合来表示（vertex），还需要另一个集合来存储所有的边，我们用E来表示(Edge)，那么一个图就可以表示为：
 G = (V，E）
 有的图的边是有方向的，有的是没有方向的。
（A,B）表示A结点与B结点之间无方向的边，&amp;lt;A,B&amp;gt;则表示方向为从A到B的一条边，当然，如果是&amp;lt;B,A&amp;gt;，则方向相反。因此从边的方向我们就可以把图分为有向图和无向图两种。
其它概念 一个图中的元素有很多，例如：
 完全图，邻接节点，结点的度，路径，权，路径长度，子图，连通图和强连通图，生成树，简单路径和回路&amp;hellip;
 本文只说说容易混淆的概念。
完全图，连通图，与强连通图 完全图可分为有向完全图和无向完全图两种，如果一个图的任意两个结点之间有且只有一条边，则称此图为无向完全图，若任意两个结点之间有且只有方向相反的两条边，则称为有向完全图。
那么连通图与完全图有什么区别呢？连通图是指在无向图中，若图中任意一对结点之间都有路径可达，则称这个无向图是连通图，而强连通图则是对应于有向图来说的，其特点与连通图是一样的。只不过是有向的，所以加了&amp;quot;强&amp;rdquo;。
连通图与完全图的区别就是，完全图要求任意两点之间有边，而连通图则是要求有路径。边和路径是有区别的。
邻接结点 一个结点的邻接节点，对于无向图来说，就是与这个结点相连的结点，至少有一个。
对于有向图来说，由于边是有方向的，所以一个结点的邻接节点是指以这个结点为开头，所指向的那些结点。
结点的度 度是针对结点来说的， 又分为出度和入度，看到“出度入度”，我们不难想到这是与边和边的方向有关的。 对于无向图来说，没有出度入度之分，一个结点的度就是经过这个结点的边的数目(或者是与这个结点相关联的边的数目)，对于有向图来说，出度就是指以这个结点为起始的边的条数（箭头向外），入度则是以这个点为终点的边的条数（箭头向内）。
出 = 箭头向外，入 = 箭头向内
权 权是指一条边所附带的数据信息，比如说一个结点到另一个结点的距离，或者花费的时间等等都可以用权来表示。带权的图也称为网格或网。
子图 跟一个集合有子集一样，图也有子图。可以类比理解。
存储结构 要存储一个图，我们知道图既有结点，又有边，对于有权图来说，每条边上还带有权值。常用的图的存储结构主要有以下二种：
 邻接矩阵 邻接表  邻接矩阵 我们知道，要表示结点，我们可以用一个一维数组来表示，然而对于结点和结点之间的关系，则无法简单地用一维数组来表示了，我们可以用二维数组来表示，也就是一个矩阵形式的表示方法。
我们假设A是这个二维数组，那么A中的一个元素aij不仅体现出了结点vi和结点vj的关系，而且aij的值正可以表示权值的大小。
以下是一个无向图的邻接矩阵表示示例：
从上图我们可以看到，无向图的邻接矩阵是对称矩阵，也一定是对称矩阵。且其左上角到右下角的对角线上值为零（对角线上表示的是相同的结点）
有向图的邻接矩阵是怎样的呢？
邻接表 我们知道，图的邻接矩阵存储方法用的是一个n*n的矩阵，当这个矩阵是稠密的矩阵（比如说当图是完全图的时候），那么当然选择用邻接矩阵存储方法。 可是如果这个矩阵是一个稀疏的矩阵呢，这个时候邻接表存储结构就是一种更节省空间的存储结构了。 对于上文中的无向图，我们可以用邻接表来表示，如下：
每一个结点后面所接的结点都是它的邻接结点。
邻接矩阵与邻接表的比较 当图中结点数目较小且边较多时，采用邻接矩阵效率更高。 当节点数目远大且边的数目远小于相同结点的完全图的边数时，采用邻接表存储结构更有效率。
邻接矩阵的Java实现 邻接矩阵模型类 邻接矩阵模型类的类名为AMWGraph.java，能够通过该类构造一个邻接矩阵表示的图，且提供插入结点，插入边，取得某一结点的第一个邻接结点和下一个邻接结点。
import java.util.ArrayList; import java.util.LinkedList; /** * @description 邻接矩阵模型类 * @author beanlam * @time 2015.</description>
    </item>
    
  </channel>
</rss>