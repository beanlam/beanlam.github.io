<!DOCTYPE html>
<html lang="cn">
  <head>
  <meta http-equiv="content-type" content="text/html;charset=utf-8">
  <meta http-equiv="X-UA-Compatible" content="chrome=1">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <meta name="robots" content="noodp"/>
  
  
  
  
  
  <link rel="prev" href="/2017/redis-master-slave-config/" />
  <link rel="next" href="/2018/distributed-transactions-intro/" />
  <link rel="canonical" href="/2017/netty-bytebuf/" />
  <link rel='shortcut icon' type='image/x-icon' href='/favicon.ico' />
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">
  <link rel="manifest" href="/site.webmanifest">
  <link rel="mask-icon" href="/safari-pinned-tab.svg" color="#5bbad5">
  <meta name="msapplication-TileColor" content="#da532c">
  <meta name="theme-color" content="#ffffff">
  <title>
       
       
           Netty4.x ByteBuf 基本机制及其骨架实现 | beanlam
       
  </title>
  <meta name="title" content="Netty4.x ByteBuf 基本机制及其骨架实现 | beanlam">
    
  
  <link rel="stylesheet" href="/font/iconfont.css">
  <link rel="stylesheet" href="/css/main.min.css">


  <meta name="twitter:card" content="summary"/>
<meta name="twitter:title" content="Netty4.x ByteBuf 基本机制及其骨架实现"/>
<meta name="twitter:description" content="概述 netty 是一个 NIO 框架，在 JDK API 已提供相对直接的 NIO Library 的情况下，几乎很少的软件系统会直接用 NIO 进行编程，也很少有开发者会直接使用 NIO 技术开发网络相关的程序。因为 native nio library 已饱受诟病，API 难用，容易出错，存在一些声称解决但还没解决的 bug（bug id = 6403933，JDK 1.7 声称解决了该 Bug，但实际上只是降低了该 bug 发生的概率），使用 native nio library 来开发可靠性、鲁棒性高的网络程序，工作量以及出错率都要更高，使用 netty 框架，就是为了解决这些问题。
ByteBuffer 的忏悔 基于 NIO 非阻塞模型的编程，基本上是面向数据容器编程，BIO 与 NIO 除了它们在阻塞 IO 线程方面有所不同外，它们在操作数据方面是有一些共性的，那就是从网络流中读数据，并放入一个容器中。 对于 BIO 来说，大多数时候，这个容器就是一个字节数组
byte[] buf = new byte[8196]; int cnt = 0; while ((cnt = input.read(buf)) != -1) { //...... } 在这里，容器就是指 buf 这个字节数组。而在 NIO 中，容器是指 ByteBuffer，由于 NIO 编程的复杂性，需要解决类似于 TCP 半包问题等，因此对这个容器的要求不仅仅是“存储数据”那么简单，还希望这个容器能提供另外的功能，这是 ByteBuffer 存在的原因，它提供了一些方便的 API，让开发者操作底层的字节数组。 然而 ByteBuffer 存在几个不得人心的缺点："/>

  <script type="application/ld+json">
{
  "@context": "http://schema.org",
  "@type": "BlogPosting",
  "headline": "Netty4.x ByteBuf 基本机制及其骨架实现",
  "mainEntityOfPage": {
    "@type": "WebPage",
    "@id": "\/2017\/netty-bytebuf\/"
  },
  "image": {
    "@type": "ImageObject",
    "url": "images\/me\/avatar.jpg",
    "width":  800 ,
    "height":  600 
  },
  "genre": "posts",
  
  "wordcount":  1464 ,
  "url": "\/2017\/netty-bytebuf\/",
  "datePublished": "2017-07-07T22:35:04\u002b08:00",
  "dateModified": "2017-07-07T22:35:04\u002b08:00",
  
  "publisher": {
    "@type": "Organization",
    "name": "beanlam",
    "logo": {
      "@type": "ImageObject",
      "url": "images\/me\/avatar.jpg",
      "width":  127 ,
      "height":  40 
    }
  },
  "author": {
    "@type": "Person",
    "name": "beanlam"
  },
  "description": ""
}
</script>
</head>

  



  <body class="">
    <div class="wrapper">
        <nav class="navbar">
    <div class="container">
        <div class="navbar-header header-logo">
        	<a href="/">beanlam</a>
        </div>
        <div class="menu navbar-right">
                
                
                <a class="menu-item" href="/posts/" title="">posts</a>
                
                <a class="menu-item" href="/categories/" title="">categories</a>
                
                <a class="menu-item" href="/about" title="">about</a>
                
                <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-sun"></i></a>&nbsp;
        </div>
    </div>
</nav>
<nav class="navbar-mobile" id="nav-mobile" style="display: none">
     <div class="container">
        <div class="navbar-header">
            <div>  <a href="javascript:void(0);" class="theme-switch"><i class="iconfont icon-sun"></i></a>&nbsp;<a href="">beanlam</a></div>
            <div class="menu-toggle">
                <span></span><span></span><span></span>
            </div>
        </div>
     
          <div class="menu" id="mobile-menu">
                
                
                <a class="menu-item" href="/posts/" title="">posts</a>
                
                <a class="menu-item" href="/categories/" title="">categories</a>
                
                <a class="menu-item" href="/about" title="">about</a>
                
        </div>
    </div>
</nav>

    	 <main class="main">
          <div class="container">
      		
<article class="post-warp">
    <header class="post-header">
        <h1 class="post-title">Netty4.x ByteBuf 基本机制及其骨架实现</h1>
        <div class="post-meta">
            本文 由 <a href="" rel="author">beanlam</a> 用一粒心 ♥ 
                <span class="post-time">
                    写于 <time datetime=2017-07-07 >7 July 2017</time>
                </span>
                分类为
                <i class="iconfont icon-folder"></i>
                <span class="post-category">
                        <a href="/categories/netty/"> netty </a>
                        
                </span>
                <i class="iconfont icon-timer"></i>
                7 min
        </div>
    </header>
    <div class="post-content">
        

        
            
        

        
        
     
          
          
          

          
          
          

          <h1 id="概述">概述</h1>
<p>netty 是一个 NIO 框架，在 JDK API 已提供相对直接的 NIO Library 的情况下，几乎很少的软件系统会直接用 NIO 进行编程，也很少有开发者会直接使用 NIO 技术开发网络相关的程序。因为 native nio library 已饱受诟病，API 难用，容易出错，存在一些声称解决但还没解决的 bug（bug id = 6403933，JDK 1.7 声称解决了该 Bug，但实际上只是降低了该 bug 发生的概率），使用 native nio library 来开发可靠性、鲁棒性高的网络程序，工作量以及出错率都要更高，使用 netty 框架，就是为了解决这些问题。</p>
<h1 id="bytebuffer-的忏悔">ByteBuffer 的忏悔</h1>
<p>基于 NIO 非阻塞模型的编程，基本上是面向数据容器编程，BIO 与 NIO 除了它们在阻塞 IO 线程方面有所不同外，它们在操作数据方面是有一些共性的，那就是从网络流中读数据，并放入一个<strong>容器</strong>中。
对于 BIO 来说，大多数时候，这个容器就是一个字节数组</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> buf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>8196<span style="color:#f92672">];</span>
<span style="color:#66d9ef">int</span> cnt <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
<span style="color:#66d9ef">while</span> <span style="color:#f92672">((</span>cnt <span style="color:#f92672">=</span> input<span style="color:#f92672">.</span><span style="color:#a6e22e">read</span><span style="color:#f92672">(</span>buf<span style="color:#f92672">))</span> <span style="color:#f92672">!=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
    <span style="color:#75715e">//......
</span><span style="color:#75715e"></span><span style="color:#f92672">}</span>
</code></pre></div><p>在这里，<strong>容器</strong>就是指 buf 这个字节数组。而在 NIO 中，容器是指 ByteBuffer，由于 NIO 编程的复杂性，需要解决类似于 TCP 半包问题等，因此对这个<strong>容器</strong>的要求不仅仅是“存储数据”那么简单，还希望这个容器能提供另外的功能，这是 ByteBuffer 存在的原因，它提供了一些方便的 API，让开发者操作底层的字节数组。
然而 ByteBuffer 存在几个不得人心的缺点：</p>
<ol>
<li>API 功能有限</li>
<li>长度固定</li>
<li>读写时的手工操作</li>
</ol>
<p>从 ByteBuffer 的源码里可以看到，它用 4 个下标来辅助管理自己身上的数据，参见它的父类 <code>java.nio.Buffer</code></p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/bytebufinternal.png" alt="ByteBuf原理" class="lazyload"><figcaption class="image-caption">ByteBuf原理</figcaption></figure></p>
<p>capacity 是 ByteBuffer 的总容量，一旦设定不能改变，就像一个水缸一样，水缸的大小永远是你看到它的时候那么大，它不会变大也不会变小，最多能装多少水是确定的；
在这里假设一种先向 ByteBuffer 写数据后再读出来的场景。往 ByteBuffer 里写入数据时，写入多少数据，position 这个下标就会增加多少，换言之，在往 ByteBuffer 写数据时，position 指向的是下一个可以写入的位置，而 limit 此时会和 capacity 一样大。开始读数据时，第一个，要知道从哪里读，第二个，要知道读到哪里为止，为此 ByteBuffer 提供了一个 flip() 方法，这个 flip() 方法将 limit 置为 position 位置，此时 limit 代表要读到哪里为止，再将 position 位置置为 0，此时 position 代表要从哪里开始读。</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/flip.png" alt="flip演示" class="lazyload"><figcaption class="image-caption">flip演示</figcaption></figure></p>
<p>因此，在读的时候，读取 position 到 limit 之间的数据，就能读到上一次写入的数据。但不得不说，这种方法显得有点笨拙，不太人性化，这意味着在编写代码的时候，要时刻谨记写完数据后，读数据之前，要先调用 flip 方法，这种“不著名”的潜规则，容易让开发者趟坑。</p>
<h1 id="bytebuf-让人耳目一新">ByteBuf 让人耳目一新</h1>
<p>netty 中的 ByteBuf 采用了新的做法，只用两个下标来辅助管理数据，分别是 readerIndex 和 writerIndex</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/bytebufinitindex.png" alt="ByteBuf初始下标位置" class="lazyload"><figcaption class="image-caption">ByteBuf初始下标位置</figcaption></figure></p>
<p>readerIndex 代表当前读取的位置，writerIndex 代表下一个可以写入的位置，写入一部分数据后，writerIndex 往右移动，而 readerIndex 和 writeIndex 之间的数据就变为可读的了。</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/afterdatawriten.png" alt="写入一部分数据后" class="lazyload"><figcaption class="image-caption">写入一部分数据后</figcaption></figure></p>
<p>如果原先写入了 N 个长度的数据，接下来读取 M (M &lt; N)个长度的数据，那么读取后 ByteBuf 就变成下面的样子</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/afterdataread.png" alt="读取一部分数据后" class="lazyload"><figcaption class="image-caption">读取一部分数据后</figcaption></figure></p>
<p>我们不再需要那笨拙的 flip 方法了，只需要关注 readerIndex 与 writerIndex。</p>
<h1 id="bytebuf-谱系">ByteBuf 谱系</h1>
<p>在 netty4.x 中，ByteBuf 是一个抽象类，但它也是在十分抽象，因为它定义的所有方法都是抽象方法，如果换我来想，我会想怎么不定义为一个 Interface 呢，ByteBuf 类也加了一个注解</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#a6e22e">@SuppressWarnings</span><span style="color:#f92672">(</span><span style="color:#e6db74">&#34;ClassMayBeInterface&#34;</span><span style="color:#f92672">)</span>
</code></pre></div><p>但这么做其实无伤大雅，留着抽象类的身份，猜测是考虑到了以后可能增加工具类方法或者公共方法。ByteBuf 下的子类如下图所示：</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/bytebufhierachy.png" alt="ByteBuf子类" class="lazyload"><figcaption class="image-caption">ByteBuf子类</figcaption></figure></p>
<p>除了 AbstractByteBuf 类，其它直接的子类都给人一种有“特殊作用”的感觉，比如说 EmptyByteBuf。最主要的类还是 AbstractByteBuf 类，它定义了大多数 ByteBuf 功能的公共逻辑代码，在 netty 应用程序的开发中，用到的 ByteBuf 的功能，以及 ByteBuf 的具体实例，都跟它有关。</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/abstractbytebufhierachy.png" alt="AbstractByteBuf谱系" class="lazyload"><figcaption class="image-caption">AbstractByteBuf谱系</figcaption></figure></p>
<h1 id="特殊作用的类">特殊作用的类</h1>
<p>与 AbstractByteBuf 同级的类有 EmptyByteBuf，UnreleasableByteBuf，SwappedByteBuf 以及 ReplayingDecoderBuffer。想要解读这些有特殊作用的类，需要先了解<strong>字节序</strong>和<strong>引用计数</strong>。</p>
<h2 id="字节序">字节序</h2>
<p>两个计算机系统之间通信，通过网络发送字节数据，双方必须为字节数据的顺序达成一致的协议，否则将无法对数据进行正确的解析，不同的计算机体系结构有不同的字节序，字节序可分为<strong>大端字节序</strong>(big-endian)和<strong>小端字节序</strong>(little-endian)。</p>
<ul>
<li>小端就是低位字节排放在内存的低地址端，高位字节排放在内存的高地址端</li>
<li>大端就是高位字节排放在内存的低地址端，低位字节排放在内存的高地址端</li>
</ul>
<p>以数字 0x12 34 56 78为例，在大端模式下，其存储的形式为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">低地址 -----------------&gt; 高地址
0x12  |  0x34  |  0x56  |  0x78
</code></pre></div><p>小端模式下，其存储形式为：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-bash" data-lang="bash">低地址 ------------------&gt; 高地址
0x78  |  0x56  |  0x34  |  0x12
</code></pre></div><p>一般情况下，基于 TCP 的网络通信约定采用大端字节序，而机器 CPU 的字节序则各有各的不同。</p>
<h2 id="swappedbytebuf-与字节序">SwappedByteBuf 与字节序</h2>
<p>SwappedByteBuf 这个类的命名并没有直接地反映出类的作用，在 ByteBuf 类中定义了一个方法，用于设置该 ByteBuf 中的数据采用的是哪种字节序存储数据：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> ByteBuf <span style="color:#a6e22e">order</span><span style="color:#f92672">(</span>ByteOrder endianness<span style="color:#f92672">);</span>
</code></pre></div><p>netty 中的 ByteBuf 默认是使用 big-endian 的，如果需要修改字节序，意味着读写数据的时候要进行顺序的转换，一般情况下我们会直接在 ByteBuf 的读写方法里去做修改，但那样意味着要修改很多个方法，netty 的做法是为每个 ByteBuf 集成一个 SwappedByteBuf，作为自身的字节序包装器。以 AbstractByteBuf 的 order 方法为例：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">order</span><span style="color:#f92672">(</span>ByteOrder endianness<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>endianness <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;endianness&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>endianness <span style="color:#f92672">==</span> order<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        SwappedByteBuf swappedBuf <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">swappedBuf</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>swappedBuf <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">swappedBuf</span> <span style="color:#f92672">=</span> swappedBuf <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> SwappedByteBuf<span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> swappedBuf<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>AbstractByteBuf 组合了一个 SwappedByteBuf 实例，当它的 order 方法被调用来设置字节序时，如果设置的字节序与自身的字节序不同，那么就将自己披上 SwappedByteBuf 外套，返回自身。接下来看 SwappedByteBuf 的具体实现，可以发现，SwappedByteBuf 里维护了被它包装的 ByteBuf，以及新的 ByteOrder。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">SwappedByteBuf</span> <span style="color:#66d9ef">extends</span> ByteBuf <span style="color:#f92672">{</span>

    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ByteBuf buf<span style="color:#f92672">;</span>
    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">final</span> ByteOrder order<span style="color:#f92672">;</span>

    <span style="color:#66d9ef">public</span> <span style="color:#a6e22e">SwappedByteBuf</span><span style="color:#f92672">(</span>ByteBuf buf<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buf <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> NullPointerException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;buf&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">buf</span> <span style="color:#f92672">=</span> buf<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buf<span style="color:#f92672">.</span><span style="color:#a6e22e">order</span><span style="color:#f92672">()</span> <span style="color:#f92672">==</span> ByteOrder<span style="color:#f92672">.</span><span style="color:#a6e22e">BIG_ENDIAN</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            order <span style="color:#f92672">=</span> ByteOrder<span style="color:#f92672">.</span><span style="color:#a6e22e">LITTLE_ENDIAN</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            order <span style="color:#f92672">=</span> ByteOrder<span style="color:#f92672">.</span><span style="color:#a6e22e">BIG_ENDIAN</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#f92672">......</span>  
<span style="color:#f92672">}</span>
</code></pre></div><p>与字节序无关的操作，都 delegate 给原来的 buf，例如：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">capacity</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> buf<span style="color:#f92672">.</span><span style="color:#a6e22e">capacity</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>而与字节序有关的操作，则根据当前的字节序，对数据进行反排序处理，例如 writeInt 方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        buf<span style="color:#f92672">.</span><span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span>ByteBufUtil<span style="color:#f92672">.</span><span style="color:#a6e22e">swapInt</span><span style="color:#f92672">(</span>value<span style="color:#f92672">));</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#75715e">/**
</span><span style="color:#75715e">     * Toggles the endianness of the specified 32-bit integer.
</span><span style="color:#75715e">     */</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">static</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">swapInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> Integer<span style="color:#f92672">.</span><span style="color:#a6e22e">reverseBytes</span><span style="color:#f92672">(</span>value<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>同样，除了写数据相关的方法，读数据相关的方法也是这么处理的。</p>
<h2 id="引用计数">引用计数</h2>
<p>netty 中 ByteBuf 用来作为数据的容器，是一种频繁被创建和销毁的对象，ByteBuf 需要的内存空间，可以在 JVM Heap 中申请分配，也可以在 Direct Memory 中申请，其中在 Direct Memory 中分配的 ByteBuf，其创建和销毁的代价比在 JVM Heap 中的更高，但抛开哪个代价高哪个代价低不说，光是频繁创建和频繁销毁这一点，就已奠定了效率不高的基调。
netty 中支持 ByteBuf 的池化，而引用计数就是实现池化的关键技术点，不过并非只有池化的 ByteBuf 才有引用计数，非池化的也会有引用计数。
ByteBuf 类实现了 ReferenceCounted 接口，该接口标记一个类是一个引用计数管理对象。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">abstract</span> <span style="color:#66d9ef">class</span> <span style="color:#a6e22e">ByteBuf</span> <span style="color:#66d9ef">implements</span> ReferenceCounted<span style="color:#f92672">,</span> Comparable<span style="color:#f92672">&lt;</span>ByteBuf<span style="color:#f92672">&gt;</span>
</code></pre></div><p>ReferenceCounted 接口定义了这几个方法：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">interface</span> <span style="color:#a6e22e">ReferenceCounted</span> <span style="color:#f92672">{</span>
    <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">refCnt</span><span style="color:#f92672">();</span>

    ReferenceCounted <span style="color:#a6e22e">retain</span><span style="color:#f92672">();</span>

    ReferenceCounted <span style="color:#a6e22e">retain</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> increment<span style="color:#f92672">);</span>

    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span><span style="color:#f92672">();</span>

    <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> decrement<span style="color:#f92672">);</span>
<span style="color:#f92672">}</span>
</code></pre></div><p>每一个引用计数对象，都维护了自身的引用计数，当第一次被创建时，引用计数为1，通过 refCnt() 方法可以得到当前的引用计数，retain() retain(int increment) 增加自身的引用计数，而 release() 和 release(int increment) 则减少当前的引用计数，如果引用计数达到 0，并且当前的 ByteBuf 被释放成功，那这两个方法的返回值为 true。需要注意的是，各种不同类型的 ByteBuf 自己决定机子的释放方式，如果是池化的 ByteBuf，那么就会进池子，如果不是池化的，则销毁底层的字节数组引用或者释放对应的堆外内存。
通过 AbstractReferenceCountedByteBuf 这个类的 release 方法实现，可以看出大概的执行逻辑：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">release</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">for</span> <span style="color:#f92672">(;;)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> refCnt <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">refCnt</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>refCnt <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalReferenceCountException<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>

            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>refCntUpdater<span style="color:#f92672">.</span><span style="color:#a6e22e">compareAndSet</span><span style="color:#f92672">(</span><span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> refCnt<span style="color:#f92672">,</span> refCnt <span style="color:#f92672">-</span> 1<span style="color:#f92672">))</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>refCnt <span style="color:#f92672">==</span> 1<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    deallocate<span style="color:#f92672">();</span>
                    <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">true</span><span style="color:#f92672">;</span>
                <span style="color:#f92672">}</span>
                <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">false</span><span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>释放对象的方法定义在 deallocate() 方法里，而它是个抽象方法。
对于非池化的 heap ByteBuf 来说，释放对象实际上就是释放底层字节数组的引用：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        array <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>对于非池化的 direct ByteBuf 来说，释放对象实际上就是释放堆外内存：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        ByteBuffer buffer <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">buffer</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>buffer <span style="color:#f92672">==</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">buffer</span> <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(!</span>doNotFree<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            PlatformDependent<span style="color:#f92672">.</span><span style="color:#a6e22e">freeDirectBuffer</span><span style="color:#f92672">(</span>buffer<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>leak <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            leak<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>对于池化的 ByteBuf 来说，就是把自己归还到对象池里：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">deallocate</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>handle <span style="color:#f92672">&gt;=</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">long</span> handle <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">handle</span><span style="color:#f92672">;</span>
            <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">handle</span> <span style="color:#f92672">=</span> <span style="color:#f92672">-</span>1<span style="color:#f92672">;</span>
            memory <span style="color:#f92672">=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">;</span>
            chunk<span style="color:#f92672">.</span><span style="color:#a6e22e">arena</span><span style="color:#f92672">.</span><span style="color:#a6e22e">free</span><span style="color:#f92672">(</span>chunk<span style="color:#f92672">,</span> handle<span style="color:#f92672">);</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>leak <span style="color:#f92672">!=</span> <span style="color:#66d9ef">null</span><span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                leak<span style="color:#f92672">.</span><span style="color:#a6e22e">close</span><span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                recycle<span style="color:#f92672">();</span>
            <span style="color:#f92672">}</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="unreleasablebytebuf-与引用计数">UnreleasableByteBuf 与引用计数</h2>
<p>顾名思义，这个类就是不可释放的 ByteBuf，它也是一个包装器模式的引用，被它包装的 ByteBuf 不会受引用计数的影响，不会被释放，它对 ReferenceCounted 接口的实现如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">retain</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> increment<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">retain</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isReadable</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> buf<span style="color:#f92672">.</span><span style="color:#a6e22e">isReadable</span><span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">boolean</span> <span style="color:#a6e22e">isWritable</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> size<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> buf<span style="color:#f92672">.</span><span style="color:#a6e22e">isWritable</span><span style="color:#f92672">(</span>size<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">refCnt</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> buf<span style="color:#f92672">.</span><span style="color:#a6e22e">refCnt</span><span style="color:#f92672">();</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>可见它直接忽略了对 retain 和 release 方法的调用效果，这种“不可释放的 ByteBuf”在什么情况下会用到呢，在一些静态的具有固定内容并且内容不改变的 ByteBuf 时候会用到，因为非常常用，所以不需要释放，会更有效率。例如在处理 HTTP 协议时候，经常需要返回带有回车换行的数据，这里回车换行就可以定义为一个静态的 ByteBuf，并且不允许释放。这有点类似于设计模式中单例模式的那个“单例”。</p>
<h2 id="emptybytebuf">EmptyByteBuf</h2>
<p>EmptyByteBuf 是一个没有任何内容，也不允许读或者写的 ByteBuf，它存在的目的是为了在调用 ByteBufAllocator 创建新 ByteBuf 的时候，如果指定容量大小为0，则返回一个 EmptyByteBuf，这里仅仅是单例模式的一个运用</p>
<h2 id="replayingdecoderbuffer">ReplayingDecoderBuffer</h2>
<p>这个 ByteBuf 专用于 ReplayingDecoder，这个 decoder 主要是为了完成对一段已知长度报文进行全包获取，因为这个场景在网络编程中太常用了，因此 netty 单独实现了一个 ReplayingDecoder 来应对这种场景。这里暂时不深入讲解 ReplayingDecoder。</p>
<h1 id="bytebuf-骨架实现">ByteBuf 骨架实现</h1>
<p>AbstractByteBuf 是 ByteBuf 的骨架实现，它实现了大部分与 ByteBuf 有关的功能方法，把不确定的行为留为抽象方法，交给它的实现者去实现。</p>
<h2 id="setter-与-getter">setter 与 getter</h2>
<p>为了实践面向对象<strong>封装</strong>的特性，见过太多类在定义其变量的 setter 和 getter 方法时，清一色地使用 **setXXX(int xxx)**和 <strong>getXXX()</strong>。不过 netty 的编码风格中，它的 setter 和 getter 方法是这样的：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">readerIndex</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> readerIndex<span style="color:#f92672">);</span> <span style="color:#75715e">// setter
</span><span style="color:#75715e"></span><span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readerIndex</span><span style="color:#f92672">();</span> <span style="color:#75715e">//getter
</span></code></pre></div><p>方法名同名，但参数列表和返回值不一样。并且对于 setter 类方法来说，它支持更加 modern 的做法，那就是方法的链式调用，setter 后返回自身，立马可以进行下一次方法调用。
但在 AbstractByteBuf 中还是有以 set 开头的的方法的，比如说：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">setIndex</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> readerIndex<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> writerIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>readerIndex <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> readerIndex <span style="color:#f92672">&gt;</span> writerIndex <span style="color:#f92672">||</span> writerIndex <span style="color:#f92672">&gt;</span> capacity<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IndexOutOfBoundsException<span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span>
                    <span style="color:#e6db74">&#34;readerIndex: %d, writerIndex: %d (expected: 0 &lt;= readerIndex &lt;= writerIndex &lt;= capacity(%d))&#34;</span><span style="color:#f92672">,</span>
                    readerIndex<span style="color:#f92672">,</span> writerIndex<span style="color:#f92672">,</span> capacity<span style="color:#f92672">()));</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">readerIndex</span> <span style="color:#f92672">=</span> readerIndex<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">writerIndex</span> <span style="color:#f92672">=</span> writerIndex<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>而其它的 set 开头的方法，则不能说它是 setter 了，因为这些方法实际上是在操作数据，为某个下标位置填入数据，例如:</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java"><span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">setByte</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">);</span>
</code></pre></div><h2 id="读取数据">读取数据</h2>
<p>AbstractByteBuf 中有两类读取数据的方法，一类以 <strong>get</strong> 开头，例如 getInt()，另一类以 <strong>read</strong> 开头，例如readInt()。这两者的区别是，get 不会导致 readerIndex 的增加，而 read 会导致 readerIndex 的增加；另一个区别是，read 只能读取已经被写入的数据，也就是说，读取的位置不能超过 writeIndex，而 get 却可以在任意位置读取，只要不超过 capacity 就可以。通过以下代码可以看出这两点区别：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">getInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        checkIndex<span style="color:#f92672">(</span>index<span style="color:#f92672">,</span> 4<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> _getInt<span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">checkIndex</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> fieldLength<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ensureAccessible<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>fieldLength <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;length: &#34;</span> <span style="color:#f92672">+</span> fieldLength <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; (expected: &gt;= 0)&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>index <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> index <span style="color:#f92672">&gt;</span> capacity<span style="color:#f92672">()</span> <span style="color:#f92672">-</span> fieldLength<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IndexOutOfBoundsException<span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span>
                    <span style="color:#e6db74">&#34;index: %d, length: %d (expected: range(0, %d))&#34;</span><span style="color:#f92672">,</span> index<span style="color:#f92672">,</span> fieldLength<span style="color:#f92672">,</span> capacity<span style="color:#f92672">()));</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>

    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">readInt</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        checkReadableBytes<span style="color:#f92672">(</span>4<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">int</span> v <span style="color:#f92672">=</span> _getInt<span style="color:#f92672">(</span>readerIndex<span style="color:#f92672">);</span>
        readerIndex <span style="color:#f92672">+=</span> 4<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> v<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>

    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">checkReadableBytes</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minimumReadableBytes<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ensureAccessible<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minimumReadableBytes <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;minimumReadableBytes: &#34;</span> <span style="color:#f92672">+</span> minimumReadableBytes <span style="color:#f92672">+</span> <span style="color:#e6db74">&#34; (expected: &gt;= 0)&#34;</span><span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>readerIndex <span style="color:#f92672">&gt;</span> writerIndex <span style="color:#f92672">-</span> minimumReadableBytes<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IndexOutOfBoundsException<span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span>
                    <span style="color:#e6db74">&#34;readerIndex(%d) + length(%d) exceeds writerIndex(%d): %s&#34;</span><span style="color:#f92672">,</span>
                    readerIndex<span style="color:#f92672">,</span> minimumReadableBytes<span style="color:#f92672">,</span> writerIndex<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>在这里也体现了出了先前提到的引用计数的作用，在读取的时候，会调用 ensureAccessible() 方法来确定当前自己的引用计数是多少。如果是 0，则此次读取时非法的。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">void</span> <span style="color:#a6e22e">ensureAccessible</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>refCnt<span style="color:#f92672">()</span> <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalReferenceCountException<span style="color:#f92672">(</span>0<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>同样，并非只有读取数据才会判断引用计数，写入数据的时候也会判断引用计数。
真正读取数据的方法，定义成了抽象方法，供不同的实现者去实现，例如 _getInt() 方法，Heap ByteBuf 的实现是直接读取底层的数组：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_getInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span>  <span style="color:#f92672">(</span>array<span style="color:#f92672">[</span>index<span style="color:#f92672">]</span>     <span style="color:#f92672">&amp;</span> 0xff<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;&lt;</span> 24 <span style="color:#f92672">|</span>
                <span style="color:#f92672">(</span>array<span style="color:#f92672">[</span>index <span style="color:#f92672">+</span> 1<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;</span> 0xff<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;&lt;</span> 16 <span style="color:#f92672">|</span>
                <span style="color:#f92672">(</span>array<span style="color:#f92672">[</span>index <span style="color:#f92672">+</span> 2<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;</span> 0xff<span style="color:#f92672">)</span> <span style="color:#f92672">&lt;&lt;</span>  8 <span style="color:#f92672">|</span>
                 array<span style="color:#f92672">[</span>index <span style="color:#f92672">+</span> 3<span style="color:#f92672">]</span> <span style="color:#f92672">&amp;</span> 0xff<span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>而 Direct ByteBuf，则是委托给了 ByteBuffer ：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">protected</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">_getInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">return</span> buffer<span style="color:#f92672">.</span><span style="color:#a6e22e">getInt</span><span style="color:#f92672">(</span>index<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><h2 id="写入数据">写入数据</h2>
<p>与读取数据一样，写入数据也分为改变 writerIndex 和不改变 writerIndex 的方法，分别是 write 开头和 set 开头。其中 set 开头的方法和读取数据时的 get 开头的方法一样，都只是检查一下有没有超过 capacity，并不会去检查 writerIndex 或者是 readerIndex，相当于说这些方法可以在任意一个地方写入数据，只要不超过 capacity，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">setInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> index<span style="color:#f92672">,</span> <span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        checkIndex<span style="color:#f92672">(</span>index<span style="color:#f92672">,</span> 4<span style="color:#f92672">);</span>
        _setInt<span style="color:#f92672">(</span>index<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>而 write 开头的方法的调用，则会对应着 writerIndex 的增长：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">writeInt</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> value<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ensureWritable<span style="color:#f92672">(</span>4<span style="color:#f92672">);</span>
        _setInt<span style="color:#f92672">(</span>writerIndex<span style="color:#f92672">,</span> value<span style="color:#f92672">);</span>
        writerIndex <span style="color:#f92672">+=</span> 4<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>注意在这里，写入操作还伴随着对是否有足够的空间写入的确定，继而伴随着 ByteBuf 的动态扩容。</p>
<h3 id="bytebuf-动态扩容机制">ByteBuf 动态扩容机制</h3>
<p>如果当前没有足够的空间写入数据了，ByteBuffer 会直接报错，而 ByteBuf 则会进行动态扩容，其扩容的主要逻辑在以下的方法里：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">ensureWritable</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minWritableBytes<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minWritableBytes <span style="color:#f92672">&lt;</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span>
                    <span style="color:#e6db74">&#34;minWritableBytes: %d (expected: &gt;= 0)&#34;</span><span style="color:#f92672">,</span> minWritableBytes<span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minWritableBytes <span style="color:#f92672">&lt;=</span> writableBytes<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minWritableBytes <span style="color:#f92672">&gt;</span> maxCapacity <span style="color:#f92672">-</span> writerIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IndexOutOfBoundsException<span style="color:#f92672">(</span>String<span style="color:#f92672">.</span><span style="color:#a6e22e">format</span><span style="color:#f92672">(</span>
                    <span style="color:#e6db74">&#34;writerIndex(%d) + minWritableBytes(%d) exceeds maxCapacity(%d): %s&#34;</span><span style="color:#f92672">,</span>
                    writerIndex<span style="color:#f92672">,</span> minWritableBytes<span style="color:#f92672">,</span> maxCapacity<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">));</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// Normalize the current capacity to the power of 2.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> calculateNewCapacity<span style="color:#f92672">(</span>writerIndex <span style="color:#f92672">+</span> minWritableBytes<span style="color:#f92672">);</span>

        <span style="color:#75715e">// Adjust to the new capacity.
</span><span style="color:#75715e"></span>        capacity<span style="color:#f92672">(</span>newCapacity<span style="color:#f92672">);</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>首先的前提是，扩容虽好，但并不意味着可以无限扩容，因此有一个 maxCapaciy 变量限制着：你可以扩容，但不可以无限扩容，我允许你走进我的世界，但不允许你在我的世界里走来走去。
扩容的逻辑主要分为两块：</p>
<ol>
<li>计算新的容量</li>
<li>扩展至新容量</li>
</ol>
<p>计算新容量的方法如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#66d9ef">private</span> <span style="color:#66d9ef">int</span> <span style="color:#a6e22e">calculateNewCapacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> minNewCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> maxCapacity <span style="color:#f92672">=</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">.</span><span style="color:#a6e22e">maxCapacity</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">final</span> <span style="color:#66d9ef">int</span> threshold <span style="color:#f92672">=</span> 1048576 <span style="color:#f92672">*</span> 4<span style="color:#f92672">;</span> <span style="color:#75715e">// 4 MiB page
</span><span style="color:#75715e"></span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minNewCapacity <span style="color:#f92672">==</span> threshold<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> threshold<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// If over threshold, do not double but just increase by threshold.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>minNewCapacity <span style="color:#f92672">&gt;</span> threshold<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> minNewCapacity <span style="color:#f92672">/</span> threshold <span style="color:#f92672">*</span> threshold<span style="color:#f92672">;</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&gt;</span> maxCapacity <span style="color:#f92672">-</span> threshold<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                newCapacity <span style="color:#f92672">=</span> maxCapacity<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                newCapacity <span style="color:#f92672">+=</span> threshold<span style="color:#f92672">;</span>
            <span style="color:#f92672">}</span>
            <span style="color:#66d9ef">return</span> newCapacity<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#75715e">// Not over threshold. Double up to 4 MiB, starting from 64.
</span><span style="color:#75715e"></span>        <span style="color:#66d9ef">int</span> newCapacity <span style="color:#f92672">=</span> 64<span style="color:#f92672">;</span>
        <span style="color:#66d9ef">while</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&lt;</span> minNewCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            newCapacity <span style="color:#f92672">&lt;&lt;=</span> 1<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">return</span> Math<span style="color:#f92672">.</span><span style="color:#a6e22e">min</span><span style="color:#f92672">(</span>newCapacity<span style="color:#f92672">,</span> maxCapacity<span style="color:#f92672">);</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>计算新容量的逻辑很简单，如果期望的新容量不超过 4MB，则从 64 字节开始，一直翻倍，直到超过期望的新容量，此时新的容量不大于 4MB，并且是 64 的倍数。如果期望的新容量已经超过了 4MB，那么就再增加 4 MB 的倍数，至于是1倍还是2倍还是N倍，由期望的容量决定。
计算完新的容量，接下来就需要把 ByteBuf 的容量扩展至新的容量，扩展容量对于不同类型的 ByteBuf 来说，其实现方式也不一样，例如对于 Heap ByteBuf 来说，扩容就意味着数组拷贝，如下所示：</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">capacity</span><span style="color:#f92672">(</span><span style="color:#66d9ef">int</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
        ensureAccessible<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&lt;</span> 0 <span style="color:#f92672">||</span> newCapacity <span style="color:#f92672">&gt;</span> maxCapacity<span style="color:#f92672">())</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">throw</span> <span style="color:#66d9ef">new</span> IllegalArgumentException<span style="color:#f92672">(</span><span style="color:#e6db74">&#34;newCapacity: &#34;</span> <span style="color:#f92672">+</span> newCapacity<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">int</span> oldCapacity <span style="color:#f92672">=</span> array<span style="color:#f92672">.</span><span style="color:#a6e22e">length</span><span style="color:#f92672">;</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&gt;</span> oldCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> newArray <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>newCapacity<span style="color:#f92672">];</span>
            System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> readerIndex<span style="color:#f92672">(),</span> newArray<span style="color:#f92672">,</span> readerIndex<span style="color:#f92672">(),</span> readableBytes<span style="color:#f92672">());</span>
            setArray<span style="color:#f92672">(</span>newArray<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>newCapacity <span style="color:#f92672">&lt;</span> oldCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">byte</span><span style="color:#f92672">[]</span> newArray <span style="color:#f92672">=</span> <span style="color:#66d9ef">new</span> <span style="color:#66d9ef">byte</span><span style="color:#f92672">[</span>newCapacity<span style="color:#f92672">];</span>
            <span style="color:#66d9ef">int</span> readerIndex <span style="color:#f92672">=</span> readerIndex<span style="color:#f92672">();</span>
            <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>readerIndex <span style="color:#f92672">&lt;</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                <span style="color:#66d9ef">int</span> writerIndex <span style="color:#f92672">=</span> writerIndex<span style="color:#f92672">();</span>
                <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>writerIndex <span style="color:#f92672">&gt;</span> newCapacity<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
                    writerIndex<span style="color:#f92672">(</span>writerIndex <span style="color:#f92672">=</span> newCapacity<span style="color:#f92672">);</span>
                <span style="color:#f92672">}</span>
                System<span style="color:#f92672">.</span><span style="color:#a6e22e">arraycopy</span><span style="color:#f92672">(</span>array<span style="color:#f92672">,</span> readerIndex<span style="color:#f92672">,</span> newArray<span style="color:#f92672">,</span> readerIndex<span style="color:#f92672">,</span> writerIndex <span style="color:#f92672">-</span> readerIndex<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
                setIndex<span style="color:#f92672">(</span>newCapacity<span style="color:#f92672">,</span> newCapacity<span style="color:#f92672">);</span>
            <span style="color:#f92672">}</span>
            setArray<span style="color:#f92672">(</span>newArray<span style="color:#f92672">);</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>这是 ByteBuf 比 ByteBuffer 更好的一个地方，既有 maxCapacity 防止无限扩容，又能在允许的范围内动态扩展容量，开发者无须关心。至于扩展的梯段为什么是 4MB，还没办法知道这个值是怎么来的，应该是经过大量的测试或者以经验来判断的。</p>
<h2 id="丢弃一部分数据">丢弃一部分数据</h2>
<p>前面提到一张图，当写入数据后读取一部分数据，被读取后的那一部分，实际上就变成了可以丢弃的数据了，否则就会有一种“占着茅坑不拉shi”的感觉了，白白占用了大量的空间</p>
<p><figure><img src="/images/ring.svg" data-sizes="auto" data-src="/assets/netty-bytebuf/discardable.png" alt="可以丢弃的数据" class="lazyload"><figcaption class="image-caption">可以丢弃的数据</figcaption></figure></p>
<p>AbstractByteBuf 提供了方法来对这些数据进行丢弃，原理其实就是将有效的数据移位，重置 readerIndex 和 writerIndex，对于 Heap ByteBuf 来说，这通常也意味着数组拷贝。</p>
<div class="highlight"><pre style="color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4"><code class="language-java" data-lang="java">    <span style="color:#a6e22e">@Override</span>
    <span style="color:#66d9ef">public</span> ByteBuf <span style="color:#a6e22e">discardReadBytes</span><span style="color:#f92672">()</span> <span style="color:#f92672">{</span>
        ensureAccessible<span style="color:#f92672">();</span>
        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>readerIndex <span style="color:#f92672">==</span> 0<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>

        <span style="color:#66d9ef">if</span> <span style="color:#f92672">(</span>readerIndex <span style="color:#f92672">!=</span> writerIndex<span style="color:#f92672">)</span> <span style="color:#f92672">{</span>
            setBytes<span style="color:#f92672">(</span>0<span style="color:#f92672">,</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">,</span> readerIndex<span style="color:#f92672">,</span> writerIndex <span style="color:#f92672">-</span> readerIndex<span style="color:#f92672">);</span>
            writerIndex <span style="color:#f92672">-=</span> readerIndex<span style="color:#f92672">;</span>
            adjustMarkers<span style="color:#f92672">(</span>readerIndex<span style="color:#f92672">);</span>
            readerIndex <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span> <span style="color:#66d9ef">else</span> <span style="color:#f92672">{</span>
            adjustMarkers<span style="color:#f92672">(</span>readerIndex<span style="color:#f92672">);</span>
            writerIndex <span style="color:#f92672">=</span> readerIndex <span style="color:#f92672">=</span> 0<span style="color:#f92672">;</span>
        <span style="color:#f92672">}</span>
        <span style="color:#66d9ef">return</span> <span style="color:#66d9ef">this</span><span style="color:#f92672">;</span>
    <span style="color:#f92672">}</span>
</code></pre></div><p>通常，<strong>数组拷贝</strong>是一个关于性能的敏感词，过多的数组拷贝，意味着效率低，因此除非能确认可以丢弃的数据占整个 ByteBuf 的大部分，否则不要轻易去显式丢弃那些已经读取的数据。</p>

    </div>

    <div class="post-copyright">
             
            <p class="copyright-item">
                <span>作者:</span>
                <span>beanlam </span>
                </p>
            
           
            <p class="copyright-item">
                    <span>字数:</span>
                   <span>1464</span>
            </p>
            
            <p class="copyright-item">
                
                <span>分享:</span>
                <span>

      
      
      
      
      
      
      
      
      
        
      
        
      

          

          

          

          
        <a href="//service.weibo.com/share/share.php?url=%2f2017%2fnetty-bytebuf%2f&amp;appkey=&amp;title=Netty4.x%20ByteBuf%20%e5%9f%ba%e6%9c%ac%e6%9c%ba%e5%88%b6%e5%8f%8a%e5%85%b6%e9%aa%a8%e6%9e%b6%e5%ae%9e%e7%8e%b0" target="_blank" title="Share on Douban ">
            <i class="iconfont icon-weibo"></i>
          </a>
          
</span>
                
            </p>

             
            <p class="copyright-item">
                本文采用 <a rel="license external nofollow noopener noreffer" href="https://creativecommons.org/licenses/by-nc/4.0/" target="_blank">知识共享署名-非商业性使用 4.0 国际许可协议 CC BY-NC 4.0</a> 进行许可
            </p>
            
    </div>

  
    <div class="post-tags">
        
        <section>
                <a href="javascript:window.history.back();">返回</a></span> · 
                <span><a href="/">主页</a></span>
        </section>
    </div>

    <div class="post-nav">
        
        <a href="/2017/redis-master-slave-config/" class="prev" rel="prev" title="redis 主从配置"><i class="iconfont icon-dajiantou"></i>&nbsp;redis 主从配置</a>
         
        
        <a href="/2018/distributed-transactions-intro/" class="next" rel="next" title="分布式事务概览">分布式事务概览&nbsp;<i class="iconfont icon-xiaojiantou"></i></a>
        
    </div>

    <div class="post-comment">
          
          <div id="gitalk-container"></div>
      <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.css" crossorigin="anonymous">
      <script src="https://cdn.jsdelivr.net/npm/gitalk@1/dist/gitalk.min.js" crossorigin="anonymous"></script>
      <script type="text/javascript">
          var gitalk = new Gitalk({
              id: '2017-07-07 22:35:04 \u002b0800 CST',
              title: 'Netty4.x ByteBuf 基本机制及其骨架实现',
              clientID: '32dbfef35e6c458d3c26',
              clientSecret: 'd1a834305aee7be0e1b2be5b18e453b39b850f26',
              repo: 'blogtalk',
              owner: 'beanlam',
              admin: ['beanlam'],
              body: decodeURI(location.href)
          });
          gitalk.render('gitalk-container');
      </script>
      <noscript>Please enable JavaScript to view the <a href="https://github.com/gitalk/gitalk">comments powered by gitalk.</a></noscript>

 

          
    </div>
</article>
          </div>
		   </main>
      <footer class="footer">
    <div class="copyright">
        &copy;
        
        <span itemprop="copyrightYear">2015 - 2020</span>
        
         
            <span class="author" itemprop="copyrightHolder"><a href="/">beanlam</a> | </span>
         

	 <span>本站由<a href="https://github.com/Fastbyte01/KeepIt" target="_blank" rel="external nofollow noopener noreffer">KeepIt</a> @ <a href="https://gohugo.io/" target="_blank" rel="external nofollow noopener noreffer">Hugo</a>驱动</span>
    </div>
</footer>












    
    <link crossorigin="anonymous" integrity="sha384-yziQACfvCVwLqVFLqkWBYRO3XeA4EqzfXKGwaWnenYn5XzqfJFlFdKEmvutIQdKb" href="https://lib.baomitu.com/lightgallery/1.6.12/css/lightgallery.min.css" rel="stylesheet">
      
     <script src="/js/vendor_gallery.min.js" async="" ></script>
    
  







     </div>
  </body>
</html>
