<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Posts on beanlam</title>
    <link>/posts/</link>
    <description>Recent content in Posts on beanlam</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>cn</language>
    <lastBuildDate>Thu, 21 Mar 2019 17:36:44 +0800</lastBuildDate>
    
	<atom:link href="/posts/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>Java 各版本的特性（更新到 Java 12）</title>
      <link>/2019/java-features/</link>
      <pubDate>Thu, 21 Mar 2019 17:36:44 +0800</pubDate>
      
      <guid>/2019/java-features/</guid>
      <description>JDK 1.1 (1997 年 2 月 19 号)  引入 JDBC (Java Database Connectivity)； 引入内部类 (Inner Classes)； 引入 Java Beans； 引入 RMI (Remote Method Invocation)； 添加只支持内省(Introspection)，但不允许在运行时改动的Java反射机制； 对 AWT(java.awt) 事件模型进行大范围的改进； 支持 Internationalization 和 Unicode；  J2SE 1.2 (1998 年 12 月 4 号)  引入 Java 插件； 引入集合(Collection)框架； 引入 JIT(Just In Time)编译器； 引入 JFC(Java Foundation Classes)，包括 Swing 1.0、拖放和 Java 2D 类库； 引入对打包的 Java 文件进行数字签名； 引入控制授权访问系统资源的策略工具； 对字符串常量做内存映射； 在 Applet 中添加声音支持； 在 JDBC 中引入可滚动结果集、BLOB、CLOB、批量更新和用户自定义类型； 新增关键字 strictfp(strict float point)； 添加可与 CORBA 协同交互的 Java IDL；  J2SE 1.</description>
    </item>
    
    <item>
      <title>关于时间的想法</title>
      <link>/2019/about-time/</link>
      <pubDate>Thu, 07 Mar 2019 11:49:40 +0800</pubDate>
      
      <guid>/2019/about-time/</guid>
      <description>工作时间与自我时间 8小时工作制，是从工业革命一直保留下来的一个传统，一直到现在的21世纪。
大多数人将“工作时间”和“自我时间”划了明确的界限，潜意识里，很多人都认为除了工作的时间，“自我时间“应该是轻松的、放松的，可以放空自己，让工作的烦恼暂时远离自己。
但正如“自我时间”这个词的表面意思所暗示的，自我的时间，其实是关注自己的时间，关注自己的目标的时间。如果你的目标是在未来的某一天，成为一个企业家，那么你应该把“自我时间”投资在如何成为一个企业家这件事上，在你的“自我时间”里，如果你认为你需要娱乐，你需要休息，那么就去娱乐，就去休息。但把“自我时间”定义为绝对的休闲、放松，是不对的。
除了工作时间和睡觉时间，每个人大概有8个小时的自我时间，意味着一年大概有3000个小时的自我时间，如果合理运用这些时间，很多事情都可以在这3000个小时内实现。
复利的威力  大多数人高估了他们一天内能做的事情，却低估了他们一年内能做的事情
 通过复利曲线，感受一下复利的威力
 1.01³⁶⁵ = 37.8 1.10³⁰ = 17.5  每天持续改进1%，坚持一年，跟每天改进10%，但只持续一个月，收效是不同的。 所以仅仅知道复利的威力是不够的，复利的核心是“持续性”，只有持续，长久地做一个事情，才会收获复利带来的效果。
事情优先级  如果每件事的优先级一样，那么等同于没有优先级
 必须为事情定义一个优先级，事情的优先级是随着时间的移动而不断动态调整的，并且具有核心优先级的事情的数量不能太多，最好低于三个。
将事情分为不同层次的优先级，层次1为最高，高优先级的事情，应该投入最多的时间。
重新组织思维方式 不要用二分法思考事情，比如说：
 技术与非技术 快乐与难过 员工与老板  一个事情，它既可以是非技术的，也可以是技术的，一个人，它可能是员工，它从某些层面来说也可以是老板。
要用关联的思维去思考事情，能让你看到更多选项，更多可能，并且在做一个事情的过程中，同时可以做另外一个事情，如果另外一个事情更吸引你，那么可以慢慢过渡到另外一个事情上。而不是非黑即白。
优化生活 注重“元任务”和“绝对任务”，把时间多花在这样的事情上。 元任务，即如果持续地做这件事一年，一年后如果的生活发生了改进，那么就属于元任务。洗了一年的衣服，买了一年的杂货，这些都不能算元任务。坚持一年的写作，一年后写作能力大幅提升，那写作就是一种元任务。如果你坚持了一年的睡前冥想，那么一年后你的心态就会变得更加平和，更能控制自己的情绪。 绝对任务与元任务的相同点是，都对自己的某方面有改进。但绝对任务带来的改进是可以量化的，实际上感受得到的，比如说，坚持了一年的健身改进了身体健康程度，身体线条更优美；坚持一年的阅读改进了阅读速度、增进了知识面。
一夜的美梦 没有人是突然过了一个晚上后就成功的。</description>
    </item>
    
    <item>
      <title>《编程大师访谈录》文摘1</title>
      <link>/2019/master-interview-pick-1/</link>
      <pubDate>Thu, 28 Feb 2019 17:50:09 +0800</pubDate>
      
      <guid>/2019/master-interview-pick-1/</guid>
      <description>查尔斯.西蒙尼 人物介绍 1948年9月10日，查尔斯·西蒙尼（Charles Simonyi）出生于匈牙利布达佩斯。上高中时，他开始接触计算机和编程，父亲安排他给一名从事计算机工作的工程师当助手，当时计算机在匈牙利屈指可数。
1966年，查尔斯高中毕业，同时也完成了他的第一个编译器。凭借开发编译器时积累的经验，他在丹麦哥本哈根的A/S Regnecentralen公司谋得了一个职位。
1968年，他离开丹麦进入美国加州大学伯克利分校学习，并于1972年获得理学学士学位，1977年获得斯坦福大学博士学位。
西蒙尼曾先后在加州大学伯克利分校计算机中心、伯克利计算机公司、ILLIAC 4项目和施乐PA R C工作。自1981年以来，他一直供职于微软公司。在施乐公司，他开发了Alto个人电脑的Bravo和Bravo X程序。在微软，他组建了应用软件小组，并领导开发出Multiplan、Microsoft Word、Microsoft Excel等广受欢迎的应用软件。
编程的步骤 编程的第一步是想象。就是要在脑海中对来龙去脉有极为清晰的把握。在这个初始阶段，我会使用纸和铅笔。我只是信手涂鸦，并不写代码。我也许会画些方框或箭头，但基本上只是涂鸦，因为真正的想法在我脑海里。我喜欢想象那些有待维护的结构，那些结构代表着我想编码的真实世界。一旦这个结构考虑得相当严谨和明确，我便开始写代码。我会坐到终端前，或者换在以前的话，就会拿张白纸，开始写代码。这相当容易。我只要把头脑中的想法变换成代码写下来，我知道结果应该是什么样的。大部分代码会水到渠成，不过我维护的那些数据结构才是关键。我会先想好数据结构，并在整个编码过程中将它们牢记于心。
团队大小 让多名程序员开发一个程序，开发速度会更快吗？ 不一定。编写同一个程序的人员越多，人均产出的实际代码量越少。结果，总的代码产出一开始会更多，之后实际上可能会减少。以两个人为例，也许单位时间只能多写百分之五十的代码。
顺便提一下，代码的效率还会随着开发同一个程序的人员数量的增加而有所降低。最高效的程序往往是一个人写的。唯一的问题是，它可能需要写上一辈子，而这显然是无法接受的。因此你需要找上三五十个，甚或好几百个人开发一个项目
巴特勒.兰普森 人物介绍 巴特勒·兰普森（Butler Lampson），目前在加州帕洛阿尔托数字设备公司（Digital Equipment Corporation，下文简称DEC①公司）系统研究中心担任高级工程师，他曾是加州大学伯克利分校计算机科学副教授、伯克利计算机公司创始人、施乐PA R C计算机科学实验室的高级研究员。
兰普森是业界最受敬重的专家之一，在许多计算机设计和研究领域都颇有建树。他开发过硬件系统，如以太网局域网和Alto、Dorado个人电脑；操作系统，如SDS 940和Alto；编程语言，如LISP和Mesa；应用程序，如Bravo编辑器和Star办公系统；还有网络服务器，如Dover打印机和Grapevine邮件系统。
物理、数学和计算机科学的联系 就物理学和数学而言，一如其他正统的学科，要想有所成就，必须能够清晰地思考。这就是计算机行业的许多成功人士都来自这些领域的原因所在。而现在人们通常一直待在计算机系，要有所成就会更加困难，因为这是一门非常浅显的学科，无法驱使你全力发挥出自己的聪明才智。
通过数学，你学会逻辑推理。你还会学到如何证明，以及怎么处理抽象要素。通过物理学等实验科学或人文学科，你学会如何应用这些抽象在现实中建立联系。
复杂性与简单性 一切都应该尽可能简单。但要做到这一点你必须掌握复杂性。
控制复杂性有一些基本技巧。从根本上，我会分而治之，把事情分解开，并准确描述各个部分应该实现什么功能。这会变成接下来如何行事的纲要。如果你还没想清楚怎么写规格，那表明你不明白具体是怎么回事。接着，你有两种选择：要么退回到你真正理解的另外某个问题上，要么更努力地思考。
此外，系统的描述不应该太庞大。也许你必须从多个较小部分的角度来考虑一个大系统。这有点像解数学题：你写的书可以包含许多有用的提示，但不能直接给出算法
约翰.沃诺克 人物介绍 约翰·沃诺克（John Warnock）出生于1940年，在犹他州长大，就读于犹他大学，并获得了数学学士和硕士学位，以及计算机科学博士学位。 沃诺克担任Adobe公司的CEO，除了Adobe公司，沃诺克还曾担任Ebrary、MongoNet、Knight-Ridder、Netscape等公司董事，目前仍然是Salon媒体集团董事会主席。他亦曾是圣何塞市创新科技馆的主席，目前还在美国电影协会和圣丹斯协会担任理事。
编程的诀窍 不要早作绑定，尽可能推迟决定时间。眼界放宽一些，设计要比你自认为需要的程度更加灵活，因为从长远看你最终会需要这样。快速让某样东西工作起来，然后还能弃之不用。
从小的开始实验而不是大的入手学习。不要一头扎进周期长达两年且中间不出什么成果的开发当中。最好每两个月就要出点成果，这样你才能进行评估、重组和重新开始。
程序员经常在一开始时过度定义他们的方法。他们可能会从一个中心构思着手，从第一天就开始编码。然后他们发现自己陷入重围，每件东西都开始膨胀，因为它们依赖于太多其他因素。应当反其道而行之，如果让过程较为宽松，保持一定的自由度，并在最后阶段加快速度，长远来说，你会做出更好的产品。
加里.基尔戴尔 人物介绍 作为数字化研究所（DRI）的创始人和董事会主席，加里·A. 基尔代尔（Gary A. Kildall）于1972年到1973年间开发了第一个微机操作系统。他把那个系统称为CP/M（控制程序/监控程序）操作系统，后来成为他们公司的第一款产品。此外，他为IBM个人计算机设计了DR Logo编程语言，并开发出微机上最早的高级计算机语言之一，PL/1。
基尔代尔是西雅图人，生于1942年5月19日。他于1972年获得华盛顿大学计算机科学博士学位，随后加入了海军，并且执教于加利福尼亚州蒙特雷的美国海军研究生院，讲授计算机科学。从海军退役后他仍旧在那里继续执教。
基尔代尔于1984年创建了一家名为Activenture的新公司（最近已更名为KnowledgeSet公司），以探索光盘出版业的潜力。Activenture公司于1985年宣布，他们将出版光盘版的《格罗利尔多媒体百科全书》。基尔代尔在担任KnowledgeSet公司总裁的同时，仍旧担任着数字化研究所董事会主席一职。
编程风格 我遵循非常明确的、适合自己的流程，虽然这些流程可能并不适合别人。我会先画数据结构，然后花很长时间思考数据结构。在开始编程前，我会一直思考整个程序的流程。
在确定数据结构之后，我就开始写一些小段的代码，并不断地改善和监测。在编码过程中进行测试可以确保所做的修改是局部的，并且如果有什么问题的话，能够马上发现。整个迭代改进的过程是需要速度的，至少对我来说，一个快速的编辑、执行和调试周期是非常重要的。
编程是否可以练习 嗯，在某种意义上是可以练习的。计算机语言（标识语）的发明家西摩·佩伯特（Seymour Papert）认为孩子们可以通过摆弄齿轮等机械小玩意而变得具有创造性。通过这种玩耍而学习和练习的技能会转移到其他领域。佩伯特的观点正是我童年的经历。我父亲是一名技艺精湛的工匠。我常常待在旁边看他干活，一看就是好几个小时，然后跑到外面，拿起锤子和钉子模仿他。
作为编程基础的数据结构，从本质上看是机械的，就像我儿时玩的东西。所以，在这个意义上讲，我是可以练习编程的。最大的不同是，木制或铁制的东西需要花好几个小时来建造，如果做得不正确，必须回去重新做。而程序可以在瞬间完成修改。
程序员积累本领的方式 你需要学习其他人的工作。他们解决问题的方法和他们使用的工具会让你以一个新的视角来审视自己的工作。在写程序前只需要学习一组为数不多的程序模块。例如，要写编译器，首先要写的是扫描功能，那是一个会用到很多次的小工具。一旦学会了这些工具，剩下的工作就只是把它们组合在一起。这里弄点儿、那里弄点儿，把这些功能模块都放到一起。查看其他人编写的程序可以为你提供构建条理清晰的代码的新思路。这就是为什么作为一个老师，我会花很多时间和学生们在一起，向他们展示我搜罗来的清晰算法模块的原因。
程序员的工作节奏 我的步调在程序开发的各个阶段是不同的。在某些时候，代码如泉涌一般，所有的东西都同时出现在脑海中：所有的变量名，变量之间的相互联系，指针从哪里开始、在哪里结束，磁盘的访问等。各种各样的事情都浮现在脑海里，因为我不停地修改自己的想法，所以没有办法写在纸上。我花在设计上的时间比花在编码上的时间多，而且我从来没有在合理的时间内完成过一个项目。
当数据结构还在雏形时，需要高度集中注意力，让它们在脑海中成形。在这个阶段我通常会在早上3点开始工作，一直干到大约下午6点，然后吃晚饭，早一点上床睡觉，再很早地起床，不断推敲构思，直到数据结构定下来。
在平静的时候，我的工作节奏会放松一些，我会提出下一阶段的解决方案。我会有步骤地去解决问题，先把问题排好次序，然后一次一个步骤地去解决——步骤A，步骤B，然后步骤C。我试过了，除非把步骤B做完，否则就无法做步骤C。
比尔.盖茨 人物介绍 作为微软的CEO，威廉·H.</description>
    </item>
    
    <item>
      <title>操作系统同步原语</title>
      <link>/2018/sync-primitive/</link>
      <pubDate>Wed, 12 Sep 2018 17:33:59 +0800</pubDate>
      
      <guid>/2018/sync-primitive/</guid>
      <description>竞态条件 在一般的操作系统中，不同的进程可能会分享一块公共的存储区域，例如内存或者是硬盘上的文件，这些进程都允许在这些区域上进行读写。 操作系统有一些职责，来协调这些使用公共区域的进程之间以正确的方式进行想要的操作。这些进程之间需要通信，需要互相沟通，有商有量，才能保证一个进程的动作不会影响到另外一个进程正常的动作，进而导致进程运行后得不到期望的结果。在操作系统概念中，通常用 IPC（Inter Process Communication，即进程间通信）这个名词来代表多个进程之间的通信。 为了解释什么是竞态条件（race condition），我们引入一个简单的例子来说明： 一个文件中保存了一个数字 n，进程 A 和进程 B 都想要去读取这个文件的数字，并把这个数字加 1 后，保存回文件。假设 n 的初始值是 0，在我们理想的情况下，进程 A 和进程 B 运行后，文件中 n 的值应该为 2，但实际上可能会发生 n 的值为 1。我们可以考量一下，每个进程做这件事时，需要经过什么步骤：
 读取文件里 n 的值 令 n = n + 1 把新的 n 值保存回文件。  在进一步解释竞态条件之前，必须先回顾操作系统概念中的几个知识点：
 进程是可以并发运行的，即使只有一个 CPU 的时候） 操作系统的时钟中断会引起进程运行的重新调度， 除了时钟中断，来自其它设备的中断也会引起进程运行的重新调度  假设进程 A 在运行完步骤 1 和 2，但还没开始运行步骤 3 时，发生了一个时钟中断，这个时候操作系统通过调度，让进程 B 开始运行，进程 B 运行步骤 1 时，发现 n 的值为 0，于是它运行步骤 2 和 3，最终会把 n = 1 保存到文件中。之后进程 A 继续运行时，由于它并不知道在它运行步骤 3 之前，进程 B 已经修改了文件里的值，所以进程 A 也会把 n = 1 写回到文件中。这就是问题所在，进程 A 在运行的过程中，会有别的进程去操作它所操作的数据。</description>
    </item>
    
    <item>
      <title>线程安全实现与 CLH 队列</title>
      <link>/2018/clh-queue/</link>
      <pubDate>Wed, 05 Sep 2018 17:40:29 +0800</pubDate>
      
      <guid>/2018/clh-queue/</guid>
      <description>阻塞同步 在 Java 中，我们经常使用 synchronized 关键字来做到互斥同步以解决多线程并发访问共享数据的问题。synchronzied 关键字在编译后，会在 synchronized 所包含的同步代码块前后分别加入 monitorenter 和 monitorexit 这两个字节码指令。synchronized 关键字需要指定一个对象来进行加锁和解锁。例如：
public class Main { private static final Object LOCK = new Object(); public static void fun1() { synchronized (LOCK) { // do something  } } public static void fun2() { synchronized (LOCK) { // do something  } } } 在没有明确指定该对象时，根据 synchonized 修饰的是实例方法还是静态方法，从而决定是采用对象实例或者类的class实例作为所对象。例如：
public class SynchronizedTest { public synchronized void doSomething() { //采用实例对象作为锁对象  } } public class SynchronizedTest { public static synchronized void doSomething() { //采用SynchronizedTest.</description>
    </item>
    
    <item>
      <title>redis sort 命令详解</title>
      <link>/2017/redis-sort-explain/</link>
      <pubDate>Wed, 07 Jun 2017 22:24:47 +0800</pubDate>
      
      <guid>/2017/redis-sort-explain/</guid>
      <description>基本使用 命令格式：
SORT key [BY pattern] [LIMIT offset count] [GET pattern [GET pattern ...]] [ASC|DESC] [ALPHA] [STORE destination] 默认情况下，排序是基于数字的，各个元素将会被转化成双精度浮点数来进行大小比较，这是SORT命令最简单的形式，也就是下面这种形式：
SORT mylist 如果mylist是一个包含了数字元素的列表，那么上面的命令将会返回升序排列的一个列表。如果想要降序排序，要使用DESC描述符，如下所示：
SORT mylist DESC 如果mylist包含的元素是string类型的，想要按字典顺序排列这个列表，那么就要用到ALPHA描述符，如下所示：
SORT mylist ALPHA Redis是基于UTF-8编码来处理数据的, 要确保你先设置好了!LC_COLLATE环境变量。
对于返回的元素个数也是可以进行限制的，只需要使用LIMIT描述符。使用这个描述符，你需要提供偏移量参数，来指定需要跳过多少个元素，返回多少个元素。 下面这个例子将会返回一个已经排序好了的列表中的10个元素，从下标为0开始：
SORT mylist LIMIT 0 10 几乎全部的描述符都可以同时使用。例如下面这个例子所示，它将会返回前5个元素，以字典顺序降序排列：
SORT mylist LIMIT 0 5 ALPHA DESC 通过外部key来排序 有时候，你会想要用外部的key来作为权重去排列列表或集合中的元素，而不是使用列表或集合中本来就有的元素来排列。 下面以一个例子来解释： 假设现在有一张这样的表，有商品id，商品价格，以及商品的重量。
   gid price_{gid} weight_{gid}     1 20 3   2 40 2   3 30 4   4 10 1    首先将上述表格的数据导入到redis中(redis版本：2.</description>
    </item>
    
    <item>
      <title>Druid SQL 解析器</title>
      <link>/2017/druid-sql-parser/</link>
      <pubDate>Wed, 07 Jun 2017 17:43:33 +0800</pubDate>
      
      <guid>/2017/druid-sql-parser/</guid>
      <description>认识 Druid Druid 是阿里巴巴公司开源的一个数据库连接池，它的口号是：为监控而生的数据库连接池
根据官方 wiki的介绍
 Druid 是一个 JDBC 组件库，包括数据库连接池、SQL Parser 等组件，DruidDataSource 是最好的数据库连接池。
 显然，官方有意无意地强调了 DruidDataSource 是最好的数据库连接池 -_- &amp;hellip;
Druid SQL 解析器 Druid 作为一个数据库连接池，功能很多，但我接触 Druid 的时候，却不是因为它有世界上最好的数据库连接池实现。而是因为有些开源项目(比如，mycat)，借用了 Druid 的 SQL 解析功能。我需要研究这个开源项目，发现作为一个数据库中间件，它的 SQL 解析功能是直接引用的 Druid，Druid 包除了 SQL 解析模块的代码外，其它的代码并没有使用到。而这部分代码显然让人在研究 SQL 解析器代码时容易分心，产生厚重感和焦虑感。
Druid 本来的代码结构如下： 提取 Druid SQL 解析器 在确认我并不需要使用到全世界最好的数据库连接池后，我想把除了 SQL 解析部分的代码全部剔除，仅仅留下 SQL 解析器模块。
一开始的做法当然是“暴力删除”，通过对代码的整体浏览，大概判断出哪些 package 与 SQL 解析有关，其余的直接删除。这样做会有些问题，比如说直接删除后在 IDE 中会立马浮现一些小红叉叉，但令人感到愉悦的是，Druid 的模块分解做得十分优秀，SQL 解析模块基本上作为一个工具模块，与其它模块实际上是分离的。
因此虽然是“暴力删除”，却也得到了一个令人满意的结果。
由于我只关注的是 Druid 对 MySQL 方言的解析，并且也不想看到 Druid 解析其它数据库方言的内容，也不愿被 Druid 那些为了适应多种数据库的“兼容性代码”混淆视听，因此狠下心来，把对其它 SQL 方言的支持也全都剔除，只留下与 MySQL 相关的代码。</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第十一章 连接池</title>
      <link>/2017/jdbc4.2-spec-11/</link>
      <pubDate>Mon, 02 Jan 2017 21:58:47 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-11/</guid>
      <description>在基本的 DataSource 实现中，客户端的 Connection 对象与物理数据库连接有着1:1的关系。当 Connection 被关闭以后，物理连接也会被关闭。因此，连接的频繁打开、初始化以及关闭，会在一个客户端会话中上演多次，带来了过重的性能消耗。 而连接池就能解决这个问题，连接池维护了一系列物理数据库连接的缓存，可以被多个客户端会话重复使用。连接池能够极大地提高性能和可扩展性，特别是在一个三层架构的环境中，大量的客户端可以共享一个数量比较小的物理数据库连接池。在图11-1中，JDBC 驱动提供了一个 ConnectionPoolDataSource 的实现，应用服务器可以用它来创建和管理连接池。
连接池的管理策略跟具体的实现有关，也跟具体的应用服务器有关。应用服务器对客户端提供了一个 DataSource 接口的具体实现，使得连接池化对于客户端来说是透明的。最终，客户端使用 DataSource API 就能和之前使用 JNDI 一样，获得了更好的性能和可扩展性。
下文将会介绍 ConnectionPoolDataSource 接口、PooledConnection 接口以及 ConnectionEvent 类，这三个组成部分是一个相互合作的关系，下文将以一个经典线程池的实现的角度，逐步描述这几部分。这一章也会介绍基本的 DataSource 对象和池化的 DataSource 对象之间的区别，此外，还会讨论一个池化的连接如何能够维护一堆可重用的 PreparedStatement 对象。
尽管本章中的所有讨论都是假设在三层架构环境下的，但连接的池化在两层架构的环境下也同样有用。 在两层架构的环境中，JDBC 驱动既实现了 DataSource 接口，也实现 ConnectionPoolDataSource 接口，这种实现方式允许客户端打开或者关闭多个连接。
11.1 ConnectionPoolDataSource 和 PooledConnection 一般来说， 一个 JDBC 驱动会去实现 ConnectionPoolDataSource 接口，应用服务器可以使用这个接口来获得 PooledConnection 对象，以下代码展示了 getPooledConnection 方法的两种版本
public interface ConnectionPoolDataSource { PooledConnection getPooledConnection() throws SQLException; PooledConnection getPooledConnection(String user, String password) throws SQLException; } 一个 PooledConnection 对象代表一条与数据源之间的物理连接。JDBC 驱动对于 PooledConnection 的实现，则会封装所有与维护这条连接相关的细节。 应用服务器则会在它的 DataSource 接口的实现中，缓存和重用这些 PooledConnection。当客户端调用 DataSource.</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第十章 事务</title>
      <link>/2017/jdbc4.2-spec-10/</link>
      <pubDate>Mon, 02 Jan 2017 21:55:52 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-10/</guid>
      <description>事务用来提供数据集成性、正确的应用语义，以及并发访问时数据的一致性视图。所有符合 JDBC 规范的驱动都必须支持事务，JDBC 的事务管理 API 参照 SQL:2003 标准并且包含了以下的概念：
 自动提交模式 事务隔离级别 Savepoints  本章讨论单个连接上的事务，涉及多条连接的事务将会在第十二章《分布式事务》中讨论。
10.1 事务边界和自动提交 什么时候应该开启一个事务，是 JDBC 驱动或者底层的数据源做的一个隐式的决定，尽管有一些数据源支持 begin transaction 语句，但这个语句没有对应的 JDBC API。当一条 SQL 语句要求开启一个事务并且当前没有事务未执行完，那么新事务就会被开启。 Connection 有一个属性 autocommit 来表明什么时候应该结束事务。如果 autocommit 启用，那么每一条 SQL 语句完全执行后，都会自动执行事务的提交。以下几种情况，视为完全执行：
 对于 DML 语句来说，例如 Insert，Update，Delete；以及 DDL 语句。这些语句在数据源端执行完毕就代表语句完全执行。 对于 Select 语句来说，完全执行意味着对应的结果集被关闭。 对于 CallableStatement 对象或者对于那些返回多个结果集的语句，完全执行意味着所有的结果集都关闭，以及所有的影响行数和出参都被获取到了。  10.1.1 关闭自动提交模式 以下代码示范了如何关闭自动提交模式：
// Assume con is a Connection object con.setAutoCommit(false); 当关闭自动提交，必须显式地调用 Connection 的 commit 方法提交事务或者调用 rollback 方法回滚事务。这种处理方式是合理的，因为事务的管理工作不是驱动应该做的，应用层应该自己管理事务，例如：
 当应用需要将一组 SQL 组成一个事务的时候 当应用服务器管理事务的时候  autocommit 的默认值为 true，如果在一个事务的过程中，autocommit 的值被改变了，那么将会导致当前事务被提交。如果调用了 setAutocommit 方法，但没有改变原来的值，则不会产生其它附加影响，相当于没有调过一样。</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第九章 连接</title>
      <link>/2017/jdbc4.2-spec-9/</link>
      <pubDate>Mon, 02 Jan 2017 21:52:29 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-9/</guid>
      <description>一个 Connection 对象，表示了与某个数据源的一条连接，数据源的种类可以是关系型数据库，文件系统等等之类，只要有对应的 JDBC 驱动，都可以称之为数据源。应用程序使用 JDBC API 来维护多条连接，这些连接可能访问的是多个数据源，也可能访问的只是一个数据源。从 JDBC 驱动的角度来看，一个 Connection 对象就意味着一个客户端会话，一个会话会保持许多状态，例如用户 ID，一系列的 SQL Statement 以及结果集，也保存了当前使用的事务处理策略。
可以通过以下两种方式之一来获取一条连接：
 使用 DriverManager 这个类以及各种各样的驱动实现 使用 DataSource 类  更推荐使用 DataSource 对象来获取连接，因为这增强了应用的可移植性，使得代码更容易维护了，并且使得对连接池和分布式事务的使用更加地透明。所有的 Java EE 组件，都会使用 DataSource 对象来获取连接。
这一章将会介绍各种不同的 JDBC 驱动以及如何使用 Driver 接口、DriverManager 类以及基本的 DataSource 接口。关于连接池和分布式事务的介绍分别在第11章和第12章做介绍。
9.1 驱动的种类  Type 1 这种类型的 JDBC 驱动是对另外一种访问 API 的映射，比如说 ODBC，一般需要依赖本地库，这就导致了它的可移植性不行。JDBC-ODBC 桥就是这种类型的驱动。 Type 2 这种类型的 JDBC 驱动一部分是用 Java 语言写的，一部分是用本地代码写的。这种驱动使用一个本地的客户端库来连接数据源。由于对本地代码的使用，可移植性也不行。 Type 3 这种类型的驱动使用纯 Java 语言编写，但是通信的时候需要经过一个中间件，使用的是与数据库具体协议无关的独立协议。这个中间件转发客户端的请求给后面的数据源。 Type 4 这种类型的驱动使用纯 Java 语言编写，并且使用网络协议或者文件 IO 与具体的数据源通信，客户端直接与数据源连接。  9.</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第八章 异常</title>
      <link>/2017/jdbc4.2-spec-8/</link>
      <pubDate>Mon, 02 Jan 2017 21:49:40 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-8/</guid>
      <description>当访问一个数据源时发生错误或者警告，JDBC 用 SQLException 这个类及其子类来表示并提供相关的异常信息。
8.1 SQLException SQLException 由一下几部分组成：
 描述错误的文本信息。可以通过 SQLException.getMessage() 来获取。 一个 SQLState 对象。可以通过 SQLException.getSQLStateType() 来获取。 错误码，是某种错误类型的一个编码，int 类型，可以通过 SQLException.getErrorCode() 来获取。 底层的异常，是一个 Throwable 对象，用来代表引起 SQLException 发生的真正原因，通过 SQLException.getCause() 来获取。 异常链的引用，如果有不止一个 SQLException 异常，可以通过递归式地调用 SQLException.getNextException 来获取整个异常链，直到这个方法返回 null，异常链结束。  8.1.1 对 Java SE 异常链的支持 SQLException 和它的子类都支持 Java SE 的异常链机制，为了实现这个功能，有以下几个地方特意做了处理：
 增加额外的四个构造函数 支持对异常链的 For-Each 语法 getCause 方法不一定会返回 SQLException 类型或者其子类型  可以参考 JDBC API Java DOC 获取更详细的信息
8.1.2 遍历多个 SQLException 在一次 SQL 语句的执行中，很有可能会发生一个或者多个异常，多个异常之间有着相应的联系，这意味着，当捕获到一个 SQLException 时，它的背后可能还有多个 SQLException 链接在它身上，为了遍历这条异常链，通常可以通过循环调用 SQLException.</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第七章 数据库元数据</title>
      <link>/2017/jdbc4.2-spec-7/</link>
      <pubDate>Mon, 02 Jan 2017 21:45:57 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-7/</guid>
      <description>JDBC 驱动需要实现 DatabaseMetaData 这个接口，以便向驱动的使用者提供一些关于底层数据源的信息。这个接口主要被应用服务器以及一些工具型代码使用，以决定如何与一个数据源交互，应用程序有时候也会使用这个接口里的方法去获得数据源的信息，但这种用法并不是典型的用法。
DatabaseMetaData 这个接口拥有超过 150 个方法，这么多的方法，可以根据它们提供的信息的类型进行分类，信息类型有：
 关于数据源通用的信息 关于数据源是否支持某个特性或者是否具有某种能力的信息 数据源的限制 数据源有哪些 SQL 对象，以及这些 SQL 对象都拥有哪些属性 数据源是否支持事务  DatabaseMetaData 接口也拥有超过 40 个字段，当调用接口的方法时，这些字段常量会作为返回值。
本章会对 DatabaseMetaData 做一个概览，给出一些实例来验证接口定义的方法，并介绍一些新的方法。如果希望更深入地理解所有的方法，建议读者参考 JDBC API Specification。
 注意，JDBC 也定义了 ResultSetMetaData 接口，这个接口我们将会在第十五章遇见它。
 7.1 创建一个 DatabaseMetaData 对象 通过 Connection 接口的 getMetaData 方法来创建一个 DatabaseMetaData  对象。一旦这个对象创建完成，就可以使用这个对象动态地查询与底层数据源有关的信息。以下代码示例创建了一个 DatabaseMetaData 对象，并使用这个对象来获取底层数据源支持的表名最大字符数是多少
// 在这里 con 是一个 Connection 对象 DatabaseMetaData dbmd = con.getMetadata(); int maxLen = dbmd.getMaxTableNameLength(); 7.2 获取通用的信息 有一些 DatabaseMetaData 接口的方法用来动态地获取底层数据源的一些通用的信息和实现细节。例如以下这些方法：
 getURL getUserName getDatabaseProductVersion, getDriverMajorVersion 和 getDriverMinorVersion getSchemaTerm, getCatalogTerm 和 getProcedureTerm nullsAreSortedHigh 和 nullsAreSortedLow usesLocalFiles 和 usesLocalFilePerTable getSQLKeyword  7.</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第六章 遵守规范</title>
      <link>/2017/jdbc4.2-spec-6/</link>
      <pubDate>Mon, 02 Jan 2017 21:41:10 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-6/</guid>
      <description>本章指出了实现一个 JDBC 驱动所需要遵守的规范，在本章中没有指出的规范，则作为可选项来遵守。
6.1 准则与要求 以下的准则是 JDBC API 规范要求实现者遵守的基本准则
  JDBC API 的实现者必须支持 Entry Level SQL92 标准，以及  Drop Table 命令。对 Entry Level SQL92 标准的支持是实现 JDBC API 的最小要求，对于 SQL99 和 SQL2003 特性的实现，必须遵照 SQL99 和 SQL2003 的规范。
  JDBC 驱动必须支持转义语法，转义语法在 第十三章 中有详细解释。
  JDBC 驱动必须支持事务，参考 第十章。
  如果 DatabaseMetaData 的某个方法指明某个特性的可用的，那么驱动必须根据这个特性的相关规范中规定的标准语法实现这个特性，如果该特性需要使用到数据源的原生 API 或者是 SQL 方言，那么由驱动负责实现从标准 SQL 语法到原生 API 或者 SQL 方言的映射关系。如果支持了某个特性，那么 DatabaseMetaData 中与这个特性相关的方法也必须提供实现。比如说，如果一个驱动实现了 RowSet 接口，那么它也应该实现 RowSetMetaData 接口。
  驱动必须提供对底层数据源特性的访问方式，包括扩展了 JDBC API 的特性。这么规定的目的是能让使用了 JDBC API 的应用程度能像数据源的原生程序一样，访问与数据源有关的特性。</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第五章 类与接口</title>
      <link>/2017/jdbc4.2-spec-5/</link>
      <pubDate>Mon, 02 Jan 2017 13:55:10 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-5/</guid>
      <description>以下的类和接口，组成了 JDBC API
5.1 java.sql包 JDBC API 的核心部分都藏在了 java.sql 这个包里，所有的枚举类，普通类以及接口，都在下方列了出来，其中，枚举和普通类是粗体，接口是正常字体。
java.sql.Array
java.sql.BatchUpdateException
java.sql.Blob
java.sql.CallableStatement
java.sql.Clob
java.sql.ClientinfoStatus
java.sql.Connection
java.sql.DataTruncation
java.sql.DatabaseMetaData
java.sql.Date
java.sql.Driver
java.sql.DriverAction
java.sql.DriverManager
java.sql.DriverPropertyInfo
java.sql.JDBCType
java.sql.NClob
java.sql.ParameterMetaData
java.sql.PreparedStatement
java.sql.PseudoColumnUsage
java.sql.Ref
java.sql.ResultSet
java.sql.ResultSetMetaData
java.sql.RowId
java.sql.RowIdLifeTime
java.sql.Savepoint
java.sql.SQLClientInfoException
java.sql.SQLData
java.sql.SQLDataException
java.sql.SQLException
java.sql.SQLFeatureNotSupportedException
java.sql.SQLInput
java.sql.SQLIntegrityConstraintViolationException
java.sql.SQLInvalidAuthorizationSpecException
java.sql.SQLNonTransientConnectionException
java.sql.SQLNonTransientException
java.sql.SQLOutput
java.sql.SQLPermission
java.sql.SQLSyntaxErrorException
java.sql.SQLTimeoutException
java.sql.SQLTransactionRollbackException
java.sql.SQLTransientConnectionException
java.sql.SQLTransientException
java.sql.SQLType
java.sql.SQLXML
java.sql.SQLWarning
java.sql.Statement
java.sql.Struct
java.sql.Time
java.sql.Timestamp
java.sql.Types
java.sql.Wrapper
下面这些类和接口是在 JDBC 4.2 API 中新增加或有过改动的，其中新增加的类和接口以粗体的形式表示
java.sql.BatchUpdateException
java.sql.CallableStatement
java.sql.Connection
java.sql.DatabaseMetaData</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第四章 JDBC API 概览</title>
      <link>/2017/jdbc4.2-spec-4/</link>
      <pubDate>Mon, 02 Jan 2017 13:46:42 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-4/</guid>
      <description>JDBC API 给 Java 程序提供了一种访问一个或者多个数据源的途径，在大多数情况下，数据源是关系型数据库，使用 SQL 语言来访问。但是，JDBC Driver 也可以实现为能够访问其它类型的数据源，比如说文件系统或面向对象的系统。 JDBC API 最主要的动机就是提供一种标准的 API ，让应用程序访问多种多样的数据源。
这一章介绍了 JDBC API 的一些关键概念，此外，也介绍 JDBC 程序的两种使用场景，分别是两层模型和三层模型，在不同的场景中，JDBC API 的功能是不一样的。
4.1 建立连接 JDBC API 定义了 Connection 接口来代表与某个数据源的一条连接。
典型情况下，JDBC 应用可以使用以下两种机制来与目标数据源建立连接
  DriverManager — 这个类从 JDBC API 1.0 版本开始就有了，当应用程序第一次尝试去连接一个数据源时，它需要指定一个url，DriverManager 将会自动加载所有它能在 CLASSPATH 下找到的 JDBC 驱动（任何 JDBC API 4.0 版本前的驱动，需要手动去加载）。
  DataSource — 这个接口在 JDBC 2.0 Optionnal Package API 中首次被引进，更推荐使用 DataSource， 因为它允许关于底层数据源的具体信息对于应用来说是透明的。需要设置 DataSource 对象的一些属性，这样才能让它代表某个数据源。当这个接口的 getConnection 方法被调用时，这个方法会返回一条与数据源建立好的连接。应用程序可以通过改变 DataSource 对象的属性，从而让它指向不同的数据源，无须改动应用代码；同时 DataSource 接口的具体实现类也可以在不改动应用程序代码的情况下，进行改变。</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第三章 新特性</title>
      <link>/2017/jdbc4.2-spec-3/</link>
      <pubDate>Mon, 02 Jan 2017 13:42:51 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-3/</guid>
      <description>JDBC API 4.2 规范在以下几个方面有所改动
3.1 增加对 REF CURSOR 的支持 有些数据库支持 REF CURSOR 数据类型，在调用存储过程后返回该类型的结果集。
3.2 支持大数量的更新 JDBC 当前的方法里返回一个更新数量时，返回的是一个 int，在某些场景下这会导致问题，因为数据集还在不停地增长。
3.3 增加 java.sql.DriverAction 接口 如果一个 driver 想要在它被 DriverManager 注销时得到通知，就要实现这个接口。
3.4 增加 java.sql.SQLType 接口 用来创建一个代表 SQL 类型的对象
3.5 增加 java.sql.JDBCType 枚举类 用来识别通用的 SQL 类型，目的是为了取代定义在 Types.java 类里的常量。
3.6 增加 Java Object 类型与 JDBC 类型的映射（附录表B-4） 增加 java.time.LocalDate 映射到 JDBC DATE
增加 java.time.LocalTime 映射到 JDBC TIME
增加 java.time.LocalDateTime 映射到 JDBC TIMESTAMP
增加 java.time.LocalOffsetTime 映射到 JDBC TIME_WITH_TIMEZONE</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第二章 目标</title>
      <link>/2017/jdbc4.2-spec-2/</link>
      <pubDate>Mon, 02 Jan 2017 13:40:18 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-2/</guid>
      <description>2.1 JDBC API 的历史 JDBC API 是一种成熟的技术，1997 年， 首次提出了 JDBC 规范，初始的版本中， JDBC API 仅提供一套针对数据库的调用级别接口。
从 2.0 版本和 2.1 版本开始，JDBC API 的功能得到增强，它能够支持更高级别的应用程序， 也提供一些高级特性，供开发应用服务器的开发者使用。
3.0 版本小范围地补充了一些遗漏的功能。
4.2 版本的目标主要有两个
 增强应用程序开发者对于 “简易开发” 的体验 增强企业应用级别的特性，提供一些工具集和 API 来更好地管理数据源  2.2 JDBC API 的目标 下面列出了 JDBC API 的目标和设计理念
2.2.1 与 Java EE 和 Java SE 平台无缝融合 JDBC API 是 Java 平台的一部分，JDBC 4.2 API 应该跟随着 Java SE 平台和 Java EE 平台的大方向走，对于 Java 语言的新特性和改进，都应该也体现在 JDBC API 4.2 的规范中。</description>
    </item>
    
    <item>
      <title>JDBC4.2规范-第一章 简介</title>
      <link>/2017/jdbc4.2-spec-1/</link>
      <pubDate>Mon, 02 Jan 2017 13:34:42 +0800</pubDate>
      
      <guid>/2017/jdbc4.2-spec-1/</guid>
      <description>1.1 JDBC API 简介 JDBC API 为 Java 语言提供了一种访问关系型数据库的方法。有了 JDBC API，应用程序便可以通过它来执行 SQL 语句、获取执行结果，以及对底层的数据库进行写入。JDBC API 也可以用来和多个数据源交互，这些数据源以分布式的形式部署。
JDBC API 基于 X/Open SQL CLI 标准，ODBC 也以它为标准。对于 X/Open SQL CLI 标准所定义的一些抽象概念，JDBC API 提供了对应的概念的映射，并且非常易用以及容易理解。
自从 1997 年 JDBC API 首次被提出以后， 它的被接受程度越来越大，并且也出现了大量的对于 JDBC API 规范的实现，这都归功于 JDBC API 本身的灵活性。
1.2 平台 JDBC API 是 Java 语言的一部分，JDBC API 分为两个 package，分别是 java.sql 和 javax.sql。在 Java SE 平台和 Java EE 平台都存在这两个 package。
1.3 目标读者  需要实现相应的驱动的数据库厂商 需要在 JDBC 驱动上建立多层服务的应用服务器厂商 需要基于 JDBC API 来开发应用的厂商  本文档也适用于任何在 JDBC API 上层开发应用的开发者</description>
    </item>
    
    <item>
      <title>redis sentinel 机制与用法</title>
      <link>/2015/redis-sentinel/</link>
      <pubDate>Fri, 17 Apr 2015 22:08:56 +0800</pubDate>
      
      <guid>/2015/redis-sentinel/</guid>
      <description>本文参考自《Redis Sentinel Documentation》
 概述 Redis-Sentinel是Redis官方推荐的高可用性(HA)解决方案，当用Redis做Master-slave的高可用方案时，假如master宕机了，Redis本身(包括它的很多客户端)都没有实现自动进行主备切换，而Redis-sentinel本身也是一个独立运行的进程，它能监控多个master-slave集群，发现master宕机后能进行自动切换。
它的主要功能有以下几点
 不时地监控redis是否按照预期良好地运行; 如果发现某个redis节点运行出现状况，能够通知另外一个进程(例如它的客户端); 能够进行自动切换。  当一个master节点不可用时，能够选举出master的多个slave(如果有超过一个slave的话)中的一个来作为新的master，其它的slave节点会将它所追随的master的地址改为被提升为master的slave的新地址。
Sentinel支持集群 很显然，只使用单个sentinel进程来监控redis集群是不可靠的，当sentinel进程宕掉后(sentinel本身也有单点问题，single-point-of-failure)整个集群系统将无法按照预期的方式运行。所以有必要将sentinel集群，这样有几个好处：
 即使有一些sentinel进程宕掉了，依然可以进行redis集群的主备切换； 如果只有一个sentinel进程，如果这个进程运行出错，或者是网络堵塞，那么将无法实现redis集群的主备切换（单点问题）; 如果有多个sentinel，redis的客户端可以随意地连接任意一个sentinel来获得关于redis集群中的信息。  Sentinel版本 Sentinel当前最新的稳定版本称为Sentinel 2(与之前的Sentinel 1区分开来）。随着redis2.8的安装包一起发行。安装完Redis2.8后，可以在**redis2.8/src/**里面找到Redis-sentinel的启动程序。
 强烈建议： 如果你使用的是redis2.6(sentinel版本为sentinel 1)，你最好应该使用redis2.8版本的sentinel 2，因为sentinel 1有很多的Bug，已经被官方弃用，所以强烈建议使用redis2.8以及sentinel 2。
 运行Sentinel 运行sentinel有两种方式：
 第一种  redis-sentinel /path/to/sentinel.conf  第二种  redis-server /path/to/sentinel.conf --sentinel 以上两种方式，都必须指定一个sentinel的配置文件sentinel.conf，如果不指定，将无法启动sentinel。sentinel默认监听26379端口，所以运行前必须确定该端口没有被别的进程占用。
Sentinel的配置 Redis源码包中包含了一个sentinel.conf文件作为sentinel的配置文件，配置文件自带了关于各个配置项的解释。典型的配置项如下所示：
sentinel monitor mymaster 127.0.0.1 6379 2 sentinel down-after-milliseconds mymaster 60000 sentinel failover-timeout mymaster 180000 sentinel parallel-syncs mymaster 1 sentinel monitor resque 192.</description>
    </item>
    
    <item>
      <title>图与其Java实现</title>
      <link>/2015/java-graph/</link>
      <pubDate>Fri, 17 Apr 2015 18:07:51 +0800</pubDate>
      
      <guid>/2015/java-graph/</guid>
      <description>图的基本概念 图是什么，图是一种数据结构，一种非线性结构，所谓的非线性结构，浅显地理解的话，就是图的存储不是像链表这样的线性存储结构，而是由两个集合所组成的一种数据结构。
一个图中有两类东西，一种是结点，一种结点之间的连线。要用一种数据结构来表示的话，首先我们需要一个集合来存储所有的点，我们用V这个集合来表示（vertex），还需要另一个集合来存储所有的边，我们用E来表示(Edge)，那么一个图就可以表示为：
 G = (V，E）
 有的图的边是有方向的，有的是没有方向的。
（A,B）表示A结点与B结点之间无方向的边，&amp;lt;A,B&amp;gt;则表示方向为从A到B的一条边，当然，如果是&amp;lt;B,A&amp;gt;，则方向相反。因此从边的方向我们就可以把图分为有向图和无向图两种。
其它概念 一个图中的元素有很多，例如：
 完全图，邻接节点，结点的度，路径，权，路径长度，子图，连通图和强连通图，生成树，简单路径和回路&amp;hellip;
 本文只说说容易混淆的概念。
完全图，连通图，与强连通图 完全图可分为有向完全图和无向完全图两种，如果一个图的任意两个结点之间有且只有一条边，则称此图为无向完全图，若任意两个结点之间有且只有方向相反的两条边，则称为有向完全图。
那么连通图与完全图有什么区别呢？连通图是指在无向图中，若图中任意一对结点之间都有路径可达，则称这个无向图是连通图，而强连通图则是对应于有向图来说的，其特点与连通图是一样的。只不过是有向的，所以加了&amp;quot;强&amp;rdquo;。
连通图与完全图的区别就是，完全图要求任意两点之间有边，而连通图则是要求有路径。边和路径是有区别的。
邻接结点 一个结点的邻接节点，对于无向图来说，就是与这个结点相连的结点，至少有一个。
对于有向图来说，由于边是有方向的，所以一个结点的邻接节点是指以这个结点为开头，所指向的那些结点。
结点的度 度是针对结点来说的， 又分为出度和入度，看到“出度入度”，我们不难想到这是与边和边的方向有关的。 对于无向图来说，没有出度入度之分，一个结点的度就是经过这个结点的边的数目(或者是与这个结点相关联的边的数目)，对于有向图来说，出度就是指以这个结点为起始的边的条数（箭头向外），入度则是以这个点为终点的边的条数（箭头向内）。
出 = 箭头向外，入 = 箭头向内
权 权是指一条边所附带的数据信息，比如说一个结点到另一个结点的距离，或者花费的时间等等都可以用权来表示。带权的图也称为网格或网。
子图 跟一个集合有子集一样，图也有子图。可以类比理解。
存储结构 要存储一个图，我们知道图既有结点，又有边，对于有权图来说，每条边上还带有权值。常用的图的存储结构主要有以下二种：
 邻接矩阵 邻接表  邻接矩阵 我们知道，要表示结点，我们可以用一个一维数组来表示，然而对于结点和结点之间的关系，则无法简单地用一维数组来表示了，我们可以用二维数组来表示，也就是一个矩阵形式的表示方法。
我们假设A是这个二维数组，那么A中的一个元素aij不仅体现出了结点vi和结点vj的关系，而且aij的值正可以表示权值的大小。
以下是一个无向图的邻接矩阵表示示例：
从上图我们可以看到，无向图的邻接矩阵是对称矩阵，也一定是对称矩阵。且其左上角到右下角的对角线上值为零（对角线上表示的是相同的结点）
有向图的邻接矩阵是怎样的呢？
邻接表 我们知道，图的邻接矩阵存储方法用的是一个n*n的矩阵，当这个矩阵是稠密的矩阵（比如说当图是完全图的时候），那么当然选择用邻接矩阵存储方法。 可是如果这个矩阵是一个稀疏的矩阵呢，这个时候邻接表存储结构就是一种更节省空间的存储结构了。 对于上文中的无向图，我们可以用邻接表来表示，如下：
每一个结点后面所接的结点都是它的邻接结点。
邻接矩阵与邻接表的比较 当图中结点数目较小且边较多时，采用邻接矩阵效率更高。 当节点数目远大且边的数目远小于相同结点的完全图的边数时，采用邻接表存储结构更有效率。
邻接矩阵的Java实现 邻接矩阵模型类 邻接矩阵模型类的类名为AMWGraph.java，能够通过该类构造一个邻接矩阵表示的图，且提供插入结点，插入边，取得某一结点的第一个邻接结点和下一个邻接结点。
import java.util.ArrayList; import java.util.LinkedList; /** * @description 邻接矩阵模型类 * @author beanlam * @time 2015.</description>
    </item>
    
  </channel>
</rss>